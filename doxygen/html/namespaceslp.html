<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: slp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.3.2-54-g7a3df61</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespaceslp.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">slp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceslp_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceslp_1_1slicing.html">slicing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_equality_constraints.html">EqualityConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of equality constraints of the form cₑ(x) = 0.  <a href="structslp_1_1_equality_constraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1function__ref.html">function_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html">function_ref&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of std::function_ref, a lightweight non-owning reference to a callable.  <a href="classslp_1_1function__ref_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the gradient of a a variable with respect to a vector of variables.  <a href="classslp_1_1_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_hessian.html">Hessian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the <a class="el" href="classslp_1_1_hessian.html" title="This class calculates the Hessian of a variable with respect to a vector of variables.">Hessian</a> of a variable with respect to a vector of variables.  <a href="classslp_1_1_hessian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of inequality constraints of the form cᵢ(x) ≥ 0.  <a href="structslp_1_1_inequality_constraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_interior_point_matrix_callbacks.html">InteriorPointMatrixCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix callbacks for the interior-point method solver.  <a href="structslp_1_1_interior_point_matrix_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom intrusive shared pointer implementation without thread synchronization overhead.  <a href="classslp_1_1_intrusive_shared_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver iteration information exposed to an iteration callback.  <a href="structslp_1_1_iteration_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_jacobian.html">Jacobian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class calculates the <a class="el" href="classslp_1_1_jacobian.html" title="This class calculates the Jacobian of a vector of variables with respect to a vector of variables.">Jacobian</a> of a vector of variables with respect to a vector of variables.  <a href="classslp_1_1_jacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_multistart_result.html">MultistartResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a multistart solve.  <a href="structslp_1_1_multistart_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_newton_matrix_callbacks.html">NewtonMatrixCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix callbacks for the Newton's method solver.  <a href="structslp_1_1_newton_matrix_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_o_c_p.html">OCP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the user to pose and solve a constrained optimal control problem (<a class="el" href="classslp_1_1_o_c_p.html" title="This class allows the user to pose and solve a constrained optimal control problem (OCP) in a variety...">OCP</a>) in a variety of ways.  <a href="classslp_1_1_o_c_p.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver options.  <a href="structslp_1_1_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_pool_allocator.html">PoolAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an allocator for the pool resource.  <a href="classslp_1_1_pool_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_pool_resource.html">PoolResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pool memory resource.  <a href="classslp_1_1_pool_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_problem.html">Problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows the user to pose a constrained nonlinear optimization problem in natural mathematical notation and solve it.  <a href="classslp_1_1_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_slice.html">Slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sequence of elements in an iterable object.  <a href="classslp_1_1_slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_spy.html">Spy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the sparsity pattern of a sparse matrix to a file.  <a href="classslp_1_1_spy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslp_1_1_s_q_p_matrix_callbacks.html">SQPMatrixCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix callbacks for the Sequential Quadratic Programming (SQP) solver.  <a href="structslp_1_1_s_q_p_matrix_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An autodiff variable pointing to an expression node.  <a href="classslp_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_variable_block.html">VariableBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A submatrix of autodiff variables with reference semantics.  <a href="classslp_1_1_variable_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of autodiff variables.  <a href="classslp_1_1_variable_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptslp_1_1_scalar_like.html">ScalarLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptslp_1_1_sleipnir_scalar_like.html">SleipnirScalarLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptslp_1_1_eigen_matrix_like.html">EigenMatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptslp_1_1_sleipnir_matrix_like.html">SleipnirMatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptslp_1_1_sleipnir_type.html">SleipnirType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptslp_1_1_matrix_like.html">MatrixLike</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab1111cace2e443b58c231cd42922099f" id="r_ab1111cace2e443b58c231cd42922099f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1111cace2e443b58c231cd42922099f">TranscriptionMethod</a> : uint8_t { <a class="el" href="#ab1111cace2e443b58c231cd42922099faddf2ce00492e4e244a4ce9959bbdf120">DIRECT_TRANSCRIPTION</a>
, <a class="el" href="#ab1111cace2e443b58c231cd42922099fa416a4fb25fab6940f88608cfbb1a51d4">DIRECT_COLLOCATION</a>
, <a class="el" href="#ab1111cace2e443b58c231cd42922099face8503337394baa9f9609898c9a788e1">SINGLE_SHOOTING</a>
 }</td></tr>
<tr class="memdesc:ab1111cace2e443b58c231cd42922099f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing an OCP transcription method.  <a href="#ab1111cace2e443b58c231cd42922099f">More...</a><br /></td></tr>
<tr class="separator:ab1111cace2e443b58c231cd42922099f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e59c61a8068f143e232c9f38beabcd" id="r_a63e59c61a8068f143e232c9f38beabcd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63e59c61a8068f143e232c9f38beabcd">DynamicsType</a> : uint8_t { <a class="el" href="#a63e59c61a8068f143e232c9f38beabcdaaf3dd33a8a0dc84d09b51c188e845890">EXPLICIT_ODE</a>
, <a class="el" href="#a63e59c61a8068f143e232c9f38beabcda947436f2927405d3b5997a9ffbaee5c1">DISCRETE</a>
 }</td></tr>
<tr class="memdesc:a63e59c61a8068f143e232c9f38beabcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing a type of system dynamics constraints.  <a href="#a63e59c61a8068f143e232c9f38beabcd">More...</a><br /></td></tr>
<tr class="separator:a63e59c61a8068f143e232c9f38beabcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce5a6644b4d22c1d73968058a524974" id="r_a1ce5a6644b4d22c1d73968058a524974"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ce5a6644b4d22c1d73968058a524974">TimestepMethod</a> : uint8_t { <a class="el" href="#a1ce5a6644b4d22c1d73968058a524974ac6e6dc18b53b4c2681394b9d8aefcec7">FIXED</a>
, <a class="el" href="#a1ce5a6644b4d22c1d73968058a524974ae61ad9b2553a293b4a3f4d3b4fa5ab31">VARIABLE</a>
, <a class="el" href="#a1ce5a6644b4d22c1d73968058a524974a083ce090f39caa0b6e411c265c25b0f5">VARIABLE_SINGLE</a>
 }</td></tr>
<tr class="memdesc:a1ce5a6644b4d22c1d73968058a524974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum describing the type of system timestep.  <a href="#a1ce5a6644b4d22c1d73968058a524974">More...</a><br /></td></tr>
<tr class="separator:a1ce5a6644b4d22c1d73968058a524974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d9dd92f6b87c30cd61389af1adb8cd" id="r_a64d9dd92f6b87c30cd61389af1adb8cd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a> : int8_t { <br />
&#160;&#160;<a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cdad0749aaba8b833466dfcbb0428e4f89c">SUCCESS</a> = 0
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cda4362c7f79da8d0fa0a552483c993b617">CALLBACK_REQUESTED_STOP</a> = 1
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cdaf54255ed22eb8d802fcc7cd1d782c7fd">TOO_FEW_DOFS</a> = -1
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cdadc01fcbff01a24a85da4853bbcfc40c0">LOCALLY_INFEASIBLE</a> = -2
, <br />
&#160;&#160;<a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cda64f63dea9464309c079c7538963b25a8">GLOBALLY_INFEASIBLE</a> = -3
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cda719355beec390097bb8c933836d1c271">FACTORIZATION_FAILED</a> = -4
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cda88449fbc3397eb36c047c6b2765acd11">LINE_SEARCH_FAILED</a> = -5
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cdaf7e64198b916bebc93d70d68a1c3fd2f">NONFINITE_INITIAL_COST_OR_CONSTRAINTS</a> = -6
, <br />
&#160;&#160;<a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cda700f32b3f4820aa7697c5d0b29539183">DIVERGING_ITERATES</a> = -7
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cdaa199f55308495569ecf2f663dbf98aee">MAX_ITERATIONS_EXCEEDED</a> = -8
, <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cda070a0fb40f6c308ab544b227660aadff">TIMEOUT</a> = -9
<br />
 }</td></tr>
<tr class="memdesc:a64d9dd92f6b87c30cd61389af1adb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver exit status.  <a href="#a64d9dd92f6b87c30cd61389af1adb8cd">More...</a><br /></td></tr>
<tr class="separator:a64d9dd92f6b87c30cd61389af1adb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f7c3be6708b8f35512e31531b025e5" id="r_a46f7c3be6708b8f35512e31531b025e5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="#a46f7c3be6708b8f35512e31531b025e5ab50339a10e1de285ac99d4c3990b8693">NONE</a>
, <a class="el" href="#a46f7c3be6708b8f35512e31531b025e5a8d6b5cada83510220f59e00ce86d4d92">CONSTANT</a>
, <a class="el" href="#a46f7c3be6708b8f35512e31531b025e5aaac544aacc3615aada24897a215f5046">LINEAR</a>
, <a class="el" href="#a46f7c3be6708b8f35512e31531b025e5aa6ef2e8b7424bfa9d56315aca733861c">QUADRATIC</a>
, <br />
&#160;&#160;<a class="el" href="#a46f7c3be6708b8f35512e31531b025e5abda8a2bc3f2b11a8313512f84864777f">NONLINEAR</a>
<br />
 }</td></tr>
<tr class="memdesc:a46f7c3be6708b8f35512e31531b025e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression type.  <a href="#a46f7c3be6708b8f35512e31531b025e5">More...</a><br /></td></tr>
<tr class="separator:a46f7c3be6708b8f35512e31531b025e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3300a70171412c36cb32d88e64f2456a" id="r_a3300a70171412c36cb32d88e64f2456a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a3300a70171412c36cb32d88e64f2456a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classslp_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3300a70171412c36cb32d88e64f2456a">make_intrusive_shared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3300a70171412c36cb32d88e64f2456a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in an intrusive shared pointer using args as the parameter list for the constructor of T.  <br /></td></tr>
<tr class="separator:a3300a70171412c36cb32d88e64f2456a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6caf5abc2a47bbaae2c6066d5c63b36" id="r_af6caf5abc2a47bbaae2c6066d5c63b36"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename... Args&gt; </td></tr>
<tr class="memitem:af6caf5abc2a47bbaae2c6066d5c63b36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classslp_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6caf5abc2a47bbaae2c6066d5c63b36">allocate_intrusive_shared</a> (Alloc alloc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af6caf5abc2a47bbaae2c6066d5c63b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T and wraps it in an intrusive shared pointer using alloc as the storage allocator of T and args as the parameter list for the constructor of T.  <br /></td></tr>
<tr class="separator:af6caf5abc2a47bbaae2c6066d5c63b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3205b1e0e0b15032292bec51c3fbef" id="r_a3e3205b1e0e0b15032292bec51c3fbef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e3205b1e0e0b15032292bec51c3fbef">cwise_reduce</a> (const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;lhs, const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;rhs, <a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classslp_1_1_variable.html">Variable</a>(const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;y)&gt; binary_op)</td></tr>
<tr class="memdesc:a3e3205b1e0e0b15032292bec51c3fbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a coefficient-wise reduce operation to two matrices.  <br /></td></tr>
<tr class="separator:a3e3205b1e0e0b15032292bec51c3fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2c23a77996d1f30972aa5221b5bfd6" id="r_a7b2c23a77996d1f30972aa5221b5bfd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b2c23a77996d1f30972aa5221b5bfd6">block</a> (std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; list)</td></tr>
<tr class="memdesc:a7b2c23a77996d1f30972aa5221b5bfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a <a class="el" href="classslp_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks.  <br /></td></tr>
<tr class="separator:a7b2c23a77996d1f30972aa5221b5bfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0b599c59a55393611074e3021a3cc" id="r_ae7e0b599c59a55393611074e3021a3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7e0b599c59a55393611074e3021a3cc">block</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; &amp;list)</td></tr>
<tr class="memdesc:ae7e0b599c59a55393611074e3021a3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a <a class="el" href="classslp_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks.  <br /></td></tr>
<tr class="separator:ae7e0b599c59a55393611074e3021a3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5fa16d9f5b98cd9a0f0805c8e3c85e" id="r_a9a5fa16d9f5b98cd9a0f0805c8e3c85e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a5fa16d9f5b98cd9a0f0805c8e3c85e">solve</a> (const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;A, const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;B)</td></tr>
<tr class="memdesc:a9a5fa16d9f5b98cd9a0f0805c8e3c85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the <a class="el" href="classslp_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> equation AX = B for X.  <br /></td></tr>
<tr class="separator:a9a5fa16d9f5b98cd9a0f0805c8e3c85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b30d031a2664632fa0682f1519d5e8" id="r_ae5b30d031a2664632fa0682f1519d5e8"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:ae5b30d031a2664632fa0682f1519d5e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5b30d031a2664632fa0682f1519d5e8">swap</a> (<a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;lhs, <a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae5b30d031a2664632fa0682f1519d5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the referred callables of <code>lhs</code> and <code>rhs</code>.  <br /></td></tr>
<tr class="separator:ae5b30d031a2664632fa0682f1519d5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1815b06747ce45e267e8813c6d572f1" id="r_aa1815b06747ce45e267e8813c6d572f1"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:aa1815b06747ce45e267e8813c6d572f1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1815b06747ce45e267e8813c6d572f1">function_ref</a> (R(*)(Args...)) -&gt; function_ref&lt; R(Args...)&gt;</td></tr>
<tr class="separator:aa1815b06747ce45e267e8813c6d572f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5c92f4f2a74d26dfa08f3c375674ba" id="r_aae5c92f4f2a74d26dfa08f3c375674ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae5c92f4f2a74d26dfa08f3c375674ba">abs</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aae5c92f4f2a74d26dfa08f3c375674ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::abs() for Variables.  <br /></td></tr>
<tr class="separator:aae5c92f4f2a74d26dfa08f3c375674ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774009580fabfac34a41a090131f8478" id="r_a774009580fabfac34a41a090131f8478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a774009580fabfac34a41a090131f8478">acos</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a774009580fabfac34a41a090131f8478"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::acos() for Variables.  <br /></td></tr>
<tr class="separator:a774009580fabfac34a41a090131f8478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b5654b815b14e62635753fbd5ae89e" id="r_af7b5654b815b14e62635753fbd5ae89e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b5654b815b14e62635753fbd5ae89e">asin</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:af7b5654b815b14e62635753fbd5ae89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::asin() for Variables.  <br /></td></tr>
<tr class="separator:af7b5654b815b14e62635753fbd5ae89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa270ed7812f41d90f66faa3115d456b" id="r_aaa270ed7812f41d90f66faa3115d456b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa270ed7812f41d90f66faa3115d456b">atan</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aaa270ed7812f41d90f66faa3115d456b"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::atan() for Variables.  <br /></td></tr>
<tr class="separator:aaa270ed7812f41d90f66faa3115d456b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44cd61021fb547d9c17b3122dd59da3" id="r_ae44cd61021fb547d9c17b3122dd59da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae44cd61021fb547d9c17b3122dd59da3">atan2</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;y, const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:ae44cd61021fb547d9c17b3122dd59da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::atan2() for Variables.  <br /></td></tr>
<tr class="separator:ae44cd61021fb547d9c17b3122dd59da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57119646ec2486451072a66c2e4f7738" id="r_a57119646ec2486451072a66c2e4f7738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57119646ec2486451072a66c2e4f7738">cos</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a57119646ec2486451072a66c2e4f7738"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cos() for Variables.  <br /></td></tr>
<tr class="separator:a57119646ec2486451072a66c2e4f7738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f161616808a05ed7355021bc556a01" id="r_af7f161616808a05ed7355021bc556a01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f161616808a05ed7355021bc556a01">cosh</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:af7f161616808a05ed7355021bc556a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::cosh() for Variables.  <br /></td></tr>
<tr class="separator:af7f161616808a05ed7355021bc556a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb7643e4c231e598b4b598a6e327558" id="r_a5fb7643e4c231e598b4b598a6e327558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb7643e4c231e598b4b598a6e327558">erf</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a5fb7643e4c231e598b4b598a6e327558"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::erf() for Variables.  <br /></td></tr>
<tr class="separator:a5fb7643e4c231e598b4b598a6e327558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5922753b1dda05845148abf3daf50421" id="r_a5922753b1dda05845148abf3daf50421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5922753b1dda05845148abf3daf50421">exp</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a5922753b1dda05845148abf3daf50421"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::exp() for Variables.  <br /></td></tr>
<tr class="separator:a5922753b1dda05845148abf3daf50421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e175f8f0059c17072fbabc1a5e5d4c" id="r_ad5e175f8f0059c17072fbabc1a5e5d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5e175f8f0059c17072fbabc1a5e5d4c">hypot</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;y)</td></tr>
<tr class="memdesc:ad5e175f8f0059c17072fbabc1a5e5d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::hypot() for Variables.  <br /></td></tr>
<tr class="separator:ad5e175f8f0059c17072fbabc1a5e5d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3d5a31cac3cfdb934951aec05e1539" id="r_a7b3d5a31cac3cfdb934951aec05e1539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b3d5a31cac3cfdb934951aec05e1539">pow</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;base, const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;power)</td></tr>
<tr class="memdesc:a7b3d5a31cac3cfdb934951aec05e1539"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::pow() for Variables.  <br /></td></tr>
<tr class="separator:a7b3d5a31cac3cfdb934951aec05e1539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a23cba26b0af9d17aa04f39e0dfd724" id="r_a8a23cba26b0af9d17aa04f39e0dfd724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a23cba26b0af9d17aa04f39e0dfd724">log</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a8a23cba26b0af9d17aa04f39e0dfd724"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::log() for Variables.  <br /></td></tr>
<tr class="separator:a8a23cba26b0af9d17aa04f39e0dfd724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570974539fd17ffe5726129b3908996f" id="r_a570974539fd17ffe5726129b3908996f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a570974539fd17ffe5726129b3908996f">log10</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a570974539fd17ffe5726129b3908996f"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::log10() for Variables.  <br /></td></tr>
<tr class="separator:a570974539fd17ffe5726129b3908996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beb6cf56fadafd356ad218ccd123828" id="r_a4beb6cf56fadafd356ad218ccd123828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4beb6cf56fadafd356ad218ccd123828">sign</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a4beb6cf56fadafd356ad218ccd123828"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="wpiutil_2src_2main_2native_2thirdparty_2fmtlib_2include_2fmt_2base_8h.html#a8c33592060c5e5568b3fa116c71610ba">sign()</a> for Variables.  <br /></td></tr>
<tr class="separator:a4beb6cf56fadafd356ad218ccd123828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef1a0468d96ccf9b7e84fef2fc5bbe7" id="r_aeef1a0468d96ccf9b7e84fef2fc5bbe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeef1a0468d96ccf9b7e84fef2fc5bbe7">sin</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aeef1a0468d96ccf9b7e84fef2fc5bbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::sin() for Variables.  <br /></td></tr>
<tr class="separator:aeef1a0468d96ccf9b7e84fef2fc5bbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33561e28e36d46c2d60a8d178f087e26" id="r_a33561e28e36d46c2d60a8d178f087e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33561e28e36d46c2d60a8d178f087e26">sinh</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a33561e28e36d46c2d60a8d178f087e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::sinh() for Variables.  <br /></td></tr>
<tr class="separator:a33561e28e36d46c2d60a8d178f087e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62d8c27a23e3a845d35092229e447a5" id="r_aa62d8c27a23e3a845d35092229e447a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa62d8c27a23e3a845d35092229e447a5">sqrt</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aa62d8c27a23e3a845d35092229e447a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::sqrt() for Variables.  <br /></td></tr>
<tr class="separator:aa62d8c27a23e3a845d35092229e447a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e317c681e1dda3e370f838785e53e" id="r_a513e317c681e1dda3e370f838785e53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513e317c681e1dda3e370f838785e53e">tan</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:a513e317c681e1dda3e370f838785e53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::tan() for Variables.  <br /></td></tr>
<tr class="separator:a513e317c681e1dda3e370f838785e53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced20c253142e62c84e6cde3d3779aa7" id="r_aced20c253142e62c84e6cde3d3779aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aced20c253142e62c84e6cde3d3779aa7">tanh</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x)</td></tr>
<tr class="memdesc:aced20c253142e62c84e6cde3d3779aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::tanh() for Variables.  <br /></td></tr>
<tr class="separator:aced20c253142e62c84e6cde3d3779aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e232ce5a84b56836ea900469e100033" id="r_a7e232ce5a84b56836ea900469e100033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e232ce5a84b56836ea900469e100033">hypot</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;y, const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;z)</td></tr>
<tr class="memdesc:a7e232ce5a84b56836ea900469e100033"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::hypot() for Variables.  <br /></td></tr>
<tr class="separator:a7e232ce5a84b56836ea900469e100033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ec38186afb059f74cba282454ef347" id="r_a53ec38186afb059f74cba282454ef347"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</td></tr>
<tr class="memitem:a53ec38186afb059f74cba282454ef347"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegch.html#ad37c85689071b4ba65fc5e4155432d1b">gch::small_vector</a>&lt; <a class="el" href="classslp_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53ec38186afb059f74cba282454ef347">make_constraints</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a53ec38186afb059f74cba282454ef347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a list of constraints.  <br /></td></tr>
<tr class="separator:a53ec38186afb059f74cba282454ef347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3718a060eb2cba0fe57ac1d8ac3fd" id="r_ae9b3718a060eb2cba0fe57ac1d8ac3fd"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</td></tr>
<tr class="memitem:ae9b3718a060eb2cba0fe57ac1d8ac3fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structslp_1_1_equality_constraints.html">EqualityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9b3718a060eb2cba0fe57ac1d8ac3fd">operator==</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ae9b3718a060eb2cba0fe57ac1d8ac3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator that returns an equality constraint for two Variables.  <br /></td></tr>
<tr class="separator:ae9b3718a060eb2cba0fe57ac1d8ac3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b54f84df8d23b6950a6d836ef7d3fac" id="r_a3b54f84df8d23b6950a6d836ef7d3fac"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</td></tr>
<tr class="memitem:a3b54f84df8d23b6950a6d836ef7d3fac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b54f84df8d23b6950a6d836ef7d3fac">operator&lt;</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a3b54f84df8d23b6950a6d836ef7d3fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:a3b54f84df8d23b6950a6d836ef7d3fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258dff8f72ecfcaea32462232a6a49c0" id="r_a258dff8f72ecfcaea32462232a6a49c0"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</td></tr>
<tr class="memitem:a258dff8f72ecfcaea32462232a6a49c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a258dff8f72ecfcaea32462232a6a49c0">operator&lt;=</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a258dff8f72ecfcaea32462232a6a49c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than-or-equal-to comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:a258dff8f72ecfcaea32462232a6a49c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c05891cc49fcf3b65e50b6e8a1122a4" id="r_a4c05891cc49fcf3b65e50b6e8a1122a4"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</td></tr>
<tr class="memitem:a4c05891cc49fcf3b65e50b6e8a1122a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4c05891cc49fcf3b65e50b6e8a1122a4">operator&gt;</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a4c05891cc49fcf3b65e50b6e8a1122a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:a4c05891cc49fcf3b65e50b6e8a1122a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b95786e1e148a77c398dbaa9f35bfd" id="r_a38b95786e1e148a77c398dbaa9f35bfd"><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</td></tr>
<tr class="memitem:a38b95786e1e148a77c398dbaa9f35bfd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38b95786e1e148a77c398dbaa9f35bfd">operator&gt;=</a> (LHS &amp;&amp;lhs, RHS &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a38b95786e1e148a77c398dbaa9f35bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than-or-equal-to comparison operator that returns an inequality constraint for two Variables.  <br /></td></tr>
<tr class="separator:a38b95786e1e148a77c398dbaa9f35bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459659bbeb1a517d714747b03925cc85" id="r_a459659bbeb1a517d714747b03925cc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_pool_resource.html">PoolResource</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a459659bbeb1a517d714747b03925cc85">global_pool_resource</a> ()</td></tr>
<tr class="memdesc:a459659bbeb1a517d714747b03925cc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global pool memory resource.  <br /></td></tr>
<tr class="separator:a459659bbeb1a517d714747b03925cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c44aad43ff9dc2c68f559d7e218f55e" id="r_a7c44aad43ff9dc2c68f559d7e218f55e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c44aad43ff9dc2c68f559d7e218f55e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classslp_1_1_pool_allocator.html">PoolAllocator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c44aad43ff9dc2c68f559d7e218f55e">global_pool_allocator</a> ()</td></tr>
<tr class="memdesc:a7c44aad43ff9dc2c68f559d7e218f55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an allocator for a global pool memory resource.  <br /></td></tr>
<tr class="separator:a7c44aad43ff9dc2c68f559d7e218f55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0df3801bb4a3e3d4bbacf11fd7b961" id="r_a4e0df3801bb4a3e3d4bbacf11fd7b961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e0df3801bb4a3e3d4bbacf11fd7b961">newton</a> (const <a class="el" href="structslp_1_1_newton_matrix_callbacks.html">NewtonMatrixCallbacks</a> &amp;matrix_callbacks, std::span&lt; std::function&lt; bool(const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a> &amp;info)&gt; &gt; iteration_callbacks, const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;options, Eigen::VectorXd &amp;x)</td></tr>
<tr class="memdesc:a4e0df3801bb4a3e3d4bbacf11fd7b961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the optimal solution to a nonlinear program using Newton's method.  <br /></td></tr>
<tr class="separator:a4e0df3801bb4a3e3d4bbacf11fd7b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608284d0d03f8be8f1911648657aa141" id="r_a608284d0d03f8be8f1911648657aa141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a608284d0d03f8be8f1911648657aa141">sqp</a> (const <a class="el" href="structslp_1_1_s_q_p_matrix_callbacks.html">SQPMatrixCallbacks</a> &amp;matrix_callbacks, std::span&lt; std::function&lt; bool(const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a> &amp;info)&gt; &gt; iteration_callbacks, const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;options, Eigen::VectorXd &amp;x)</td></tr>
<tr class="memdesc:a608284d0d03f8be8f1911648657aa141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the optimal solution to a nonlinear program using Sequential Quadratic Programming (SQP).  <br /></td></tr>
<tr class="separator:a608284d0d03f8be8f1911648657aa141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa2a313c44bd67df8044c72c432a86c" id="r_a6fa2a313c44bd67df8044c72c432a86c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa2a313c44bd67df8044c72c432a86c">interior_point</a> (const <a class="el" href="structslp_1_1_interior_point_matrix_callbacks.html">InteriorPointMatrixCallbacks</a> &amp;matrix_callbacks, std::span&lt; std::function&lt; bool(const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a> &amp;info)&gt; &gt; iteration_callbacks, const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;options, Eigen::VectorXd &amp;x)</td></tr>
<tr class="memdesc:a6fa2a313c44bd67df8044c72c432a86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the optimal solution to a nonlinear program using the interior-point method.  <br /></td></tr>
<tr class="separator:a6fa2a313c44bd67df8044c72c432a86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf0981a979a0c79a3319f76ff5584c8" id="r_addf0981a979a0c79a3319f76ff5584c8"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:addf0981a979a0c79a3319f76ff5584c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#addf0981a979a0c79a3319f76ff5584c8">print</a> (fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:addf0981a979a0c79a3319f76ff5584c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::print() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:addf0981a979a0c79a3319f76ff5584c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c88ae28619e062683faff1ab21740a" id="r_a98c88ae28619e062683faff1ab21740a"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a98c88ae28619e062683faff1ab21740a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a98c88ae28619e062683faff1ab21740a">print</a> (std::FILE *f, fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a98c88ae28619e062683faff1ab21740a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::print() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a98c88ae28619e062683faff1ab21740a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac564720b4a398578532f97682ecf39c6" id="r_ac564720b4a398578532f97682ecf39c6"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ac564720b4a398578532f97682ecf39c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac564720b4a398578532f97682ecf39c6">println</a> (fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac564720b4a398578532f97682ecf39c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::println() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:ac564720b4a398578532f97682ecf39c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979c7cfc5ade9d54b85e81dd6deb6410" id="r_a979c7cfc5ade9d54b85e81dd6deb6410"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a979c7cfc5ade9d54b85e81dd6deb6410"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a979c7cfc5ade9d54b85e81dd6deb6410">println</a> (std::FILE *f, fmt::format_string&lt; T... &gt; fmt, T &amp;&amp;... args)</td></tr>
<tr class="memdesc:a979c7cfc5ade9d54b85e81dd6deb6410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around fmt::println() that squelches write failure exceptions.  <br /></td></tr>
<tr class="separator:a979c7cfc5ade9d54b85e81dd6deb6410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c35bde4490817185cdde27e2b2694fb" id="r_a0c35bde4490817185cdde27e2b2694fb"><td class="memTemplParams" colspan="2">template&lt;typename F , typename State , typename Input , typename Time &gt; </td></tr>
<tr class="memitem:a0c35bde4490817185cdde27e2b2694fb"><td class="memTemplItemLeft" align="right" valign="top">State&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c35bde4490817185cdde27e2b2694fb">rk4</a> (F &amp;&amp;f, State x, Input u, Time t0, Time dt)</td></tr>
<tr class="memdesc:a0c35bde4490817185cdde27e2b2694fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 4th order Runge-Kutta integration of dx/dt = f(t, x, u) for dt.  <br /></td></tr>
<tr class="separator:a0c35bde4490817185cdde27e2b2694fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992ddea754700b70b528b6e035ec7905" id="r_a992ddea754700b70b528b6e035ec7905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a992ddea754700b70b528b6e035ec7905">to_message</a> (const <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a> &amp;exit_status)</td></tr>
<tr class="memdesc:a992ddea754700b70b528b6e035ec7905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns user-readable message corresponding to the solver exit status.  <br /></td></tr>
<tr class="separator:a992ddea754700b70b528b6e035ec7905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11876ec2872473641550f1b4b461baf2" id="r_a11876ec2872473641550f1b4b461baf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11876ec2872473641550f1b4b461baf2">to_message</a> (const <a class="el" href="#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a> &amp;type)</td></tr>
<tr class="memdesc:a11876ec2872473641550f1b4b461baf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns user-readable message corresponding to the expression type.  <br /></td></tr>
<tr class="separator:a11876ec2872473641550f1b4b461baf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c65b2c9d67bcc9e69e7287a59d6e12" id="r_ad8c65b2c9d67bcc9e69e7287a59d6e12"><td class="memTemplParams" colspan="2">template&lt;typename DecisionVariables &gt; </td></tr>
<tr class="memitem:ad8c65b2c9d67bcc9e69e7287a59d6e12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structslp_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8c65b2c9d67bcc9e69e7287a59d6e12">Multistart</a> (<a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="structslp_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;(const DecisionVariables &amp;initial_guess)&gt; <a class="el" href="#a9a5fa16d9f5b98cd9a0f0805c8e3c85e">solve</a>, std::span&lt; const DecisionVariables &gt; initial_guesses)</td></tr>
<tr class="memdesc:ad8c65b2c9d67bcc9e69e7287a59d6e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization problem from different starting points in parallel, then returns the solution with the lowest cost.  <br /></td></tr>
<tr class="separator:ad8c65b2c9d67bcc9e69e7287a59d6e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7fa06f348bbf7df69e2780efa1e157fb" id="r_a7fa06f348bbf7df69e2780efa1e157fb"><td class="memTemplParams" colspan="2">template&lt;int UpLo = Eigen::Lower | Eigen::Upper&gt; </td></tr>
<tr class="memitem:a7fa06f348bbf7df69e2780efa1e157fb"><td class="memTemplItemLeft" align="right" valign="top">class <a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7fa06f348bbf7df69e2780efa1e157fb">Hessian</a></td></tr>
<tr class="separator:a7fa06f348bbf7df69e2780efa1e157fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baa5511d10c78d3b75925f032613ced" id="r_a2baa5511d10c78d3b75925f032613ced"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2baa5511d10c78d3b75925f032613ced">Jacobian</a></td></tr>
<tr class="separator:a2baa5511d10c78d3b75925f032613ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a63e59c61a8068f143e232c9f38beabcd" name="a63e59c61a8068f143e232c9f38beabcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e59c61a8068f143e232c9f38beabcd">&#9670;&#160;</a></span>DynamicsType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a63e59c61a8068f143e232c9f38beabcd">slp::DynamicsType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing a type of system dynamics constraints. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a63e59c61a8068f143e232c9f38beabcdaaf3dd33a8a0dc84d09b51c188e845890" name="a63e59c61a8068f143e232c9f38beabcdaaf3dd33a8a0dc84d09b51c188e845890"></a>EXPLICIT_ODE&#160;</td><td class="fielddoc"><p>The dynamics are a function in the form dx/dt = f(t, x, u). </p>
</td></tr>
<tr><td class="fieldname"><a id="a63e59c61a8068f143e232c9f38beabcda947436f2927405d3b5997a9ffbaee5c1" name="a63e59c61a8068f143e232c9f38beabcda947436f2927405d3b5997a9ffbaee5c1"></a>DISCRETE&#160;</td><td class="fielddoc"><p>The dynamics are a function in the form xₖ₊₁ = f(t, xₖ, uₖ). </p>
</td></tr>
</table>

</div>
</div>
<a id="a64d9dd92f6b87c30cd61389af1adb8cd" name="a64d9dd92f6b87c30cd61389af1adb8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d9dd92f6b87c30cd61389af1adb8cd">&#9670;&#160;</a></span>ExitStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">slp::ExitStatus</a> : int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solver exit status. </p>
<p>Negative values indicate failure. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cdad0749aaba8b833466dfcbb0428e4f89c" name="a64d9dd92f6b87c30cd61389af1adb8cdad0749aaba8b833466dfcbb0428e4f89c"></a>SUCCESS&#160;</td><td class="fielddoc"><p>Solved the problem to the desired tolerance. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cda4362c7f79da8d0fa0a552483c993b617" name="a64d9dd92f6b87c30cd61389af1adb8cda4362c7f79da8d0fa0a552483c993b617"></a>CALLBACK_REQUESTED_STOP&#160;</td><td class="fielddoc"><p>The solver returned its solution so far after the user requested a stop. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cdaf54255ed22eb8d802fcc7cd1d782c7fd" name="a64d9dd92f6b87c30cd61389af1adb8cdaf54255ed22eb8d802fcc7cd1d782c7fd"></a>TOO_FEW_DOFS&#160;</td><td class="fielddoc"><p>The solver determined the problem to be overconstrained and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cdadc01fcbff01a24a85da4853bbcfc40c0" name="a64d9dd92f6b87c30cd61389af1adb8cdadc01fcbff01a24a85da4853bbcfc40c0"></a>LOCALLY_INFEASIBLE&#160;</td><td class="fielddoc"><p>The solver determined the problem to be locally infeasible and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cda64f63dea9464309c079c7538963b25a8" name="a64d9dd92f6b87c30cd61389af1adb8cda64f63dea9464309c079c7538963b25a8"></a>GLOBALLY_INFEASIBLE&#160;</td><td class="fielddoc"><p>The problem setup frontend determined the problem to have an empty feasible region. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cda719355beec390097bb8c933836d1c271" name="a64d9dd92f6b87c30cd61389af1adb8cda719355beec390097bb8c933836d1c271"></a>FACTORIZATION_FAILED&#160;</td><td class="fielddoc"><p>The linear system factorization failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cda88449fbc3397eb36c047c6b2765acd11" name="a64d9dd92f6b87c30cd61389af1adb8cda88449fbc3397eb36c047c6b2765acd11"></a>LINE_SEARCH_FAILED&#160;</td><td class="fielddoc"><p>The backtracking line search failed, and the problem isn't locally infeasible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cdaf7e64198b916bebc93d70d68a1c3fd2f" name="a64d9dd92f6b87c30cd61389af1adb8cdaf7e64198b916bebc93d70d68a1c3fd2f"></a>NONFINITE_INITIAL_COST_OR_CONSTRAINTS&#160;</td><td class="fielddoc"><p>The solver encountered nonfinite initial cost or constraints and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cda700f32b3f4820aa7697c5d0b29539183" name="a64d9dd92f6b87c30cd61389af1adb8cda700f32b3f4820aa7697c5d0b29539183"></a>DIVERGING_ITERATES&#160;</td><td class="fielddoc"><p>The solver encountered diverging primal iterates xₖ and/or sₖ and gave up. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cdaa199f55308495569ecf2f663dbf98aee" name="a64d9dd92f6b87c30cd61389af1adb8cdaa199f55308495569ecf2f663dbf98aee"></a>MAX_ITERATIONS_EXCEEDED&#160;</td><td class="fielddoc"><p>The solver returned its solution so far after exceeding the maximum number of iterations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a64d9dd92f6b87c30cd61389af1adb8cda070a0fb40f6c308ab544b227660aadff" name="a64d9dd92f6b87c30cd61389af1adb8cda070a0fb40f6c308ab544b227660aadff"></a>TIMEOUT&#160;</td><td class="fielddoc"><p>The solver returned its solution so far after exceeding the maximum elapsed wall clock time. </p>
</td></tr>
</table>

</div>
</div>
<a id="a46f7c3be6708b8f35512e31531b025e5" name="a46f7c3be6708b8f35512e31531b025e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f7c3be6708b8f35512e31531b025e5">&#9670;&#160;</a></span>ExpressionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a46f7c3be6708b8f35512e31531b025e5">slp::ExpressionType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expression type. </p>
<p>Used for autodiff caching. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a46f7c3be6708b8f35512e31531b025e5ab50339a10e1de285ac99d4c3990b8693" name="a46f7c3be6708b8f35512e31531b025e5ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>There is no expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a46f7c3be6708b8f35512e31531b025e5a8d6b5cada83510220f59e00ce86d4d92" name="a46f7c3be6708b8f35512e31531b025e5a8d6b5cada83510220f59e00ce86d4d92"></a>CONSTANT&#160;</td><td class="fielddoc"><p>The expression is a constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a46f7c3be6708b8f35512e31531b025e5aaac544aacc3615aada24897a215f5046" name="a46f7c3be6708b8f35512e31531b025e5aaac544aacc3615aada24897a215f5046"></a>LINEAR&#160;</td><td class="fielddoc"><p>The expression is composed of linear and lower-order operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a46f7c3be6708b8f35512e31531b025e5aa6ef2e8b7424bfa9d56315aca733861c" name="a46f7c3be6708b8f35512e31531b025e5aa6ef2e8b7424bfa9d56315aca733861c"></a>QUADRATIC&#160;</td><td class="fielddoc"><p>The expression is composed of quadratic and lower-order operators. </p>
</td></tr>
<tr><td class="fieldname"><a id="a46f7c3be6708b8f35512e31531b025e5abda8a2bc3f2b11a8313512f84864777f" name="a46f7c3be6708b8f35512e31531b025e5abda8a2bc3f2b11a8313512f84864777f"></a>NONLINEAR&#160;</td><td class="fielddoc"><p>The expression is composed of nonlinear and lower-order operators. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1ce5a6644b4d22c1d73968058a524974" name="a1ce5a6644b4d22c1d73968058a524974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce5a6644b4d22c1d73968058a524974">&#9670;&#160;</a></span>TimestepMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a1ce5a6644b4d22c1d73968058a524974">slp::TimestepMethod</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing the type of system timestep. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ce5a6644b4d22c1d73968058a524974ac6e6dc18b53b4c2681394b9d8aefcec7" name="a1ce5a6644b4d22c1d73968058a524974ac6e6dc18b53b4c2681394b9d8aefcec7"></a>FIXED&#160;</td><td class="fielddoc"><p>The timestep is a fixed constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1ce5a6644b4d22c1d73968058a524974ae61ad9b2553a293b4a3f4d3b4fa5ab31" name="a1ce5a6644b4d22c1d73968058a524974ae61ad9b2553a293b4a3f4d3b4fa5ab31"></a>VARIABLE&#160;</td><td class="fielddoc"><p>The timesteps are allowed to vary as independent decision variables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1ce5a6644b4d22c1d73968058a524974a083ce090f39caa0b6e411c265c25b0f5" name="a1ce5a6644b4d22c1d73968058a524974a083ce090f39caa0b6e411c265c25b0f5"></a>VARIABLE_SINGLE&#160;</td><td class="fielddoc"><p>The timesteps are equal length but allowed to vary as a single decision variable. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab1111cace2e443b58c231cd42922099f" name="ab1111cace2e443b58c231cd42922099f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1111cace2e443b58c231cd42922099f">&#9670;&#160;</a></span>TranscriptionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ab1111cace2e443b58c231cd42922099f">slp::TranscriptionMethod</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum describing an <a class="el" href="classslp_1_1_o_c_p.html" title="This class allows the user to pose and solve a constrained optimal control problem (OCP) in a variety...">OCP</a> transcription method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab1111cace2e443b58c231cd42922099faddf2ce00492e4e244a4ce9959bbdf120" name="ab1111cace2e443b58c231cd42922099faddf2ce00492e4e244a4ce9959bbdf120"></a>DIRECT_TRANSCRIPTION&#160;</td><td class="fielddoc"><p>Each state is a decision variable constrained to the integrated dynamics of the previous state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1111cace2e443b58c231cd42922099fa416a4fb25fab6940f88608cfbb1a51d4" name="ab1111cace2e443b58c231cd42922099fa416a4fb25fab6940f88608cfbb1a51d4"></a>DIRECT_COLLOCATION&#160;</td><td class="fielddoc"><p>The trajectory is modeled as a series of cubic polynomials where the centerpoint slope is constrained. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1111cace2e443b58c231cd42922099face8503337394baa9f9609898c9a788e1" name="ab1111cace2e443b58c231cd42922099face8503337394baa9f9609898c9a788e1"></a>SINGLE_SHOOTING&#160;</td><td class="fielddoc"><p>States depend explicitly as a function of all previous states and all previous inputs. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae5c92f4f2a74d26dfa08f3c375674ba" name="aae5c92f4f2a74d26dfa08f3c375674ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5c92f4f2a74d26dfa08f3c375674ba">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::abs() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a774009580fabfac34a41a090131f8478" name="a774009580fabfac34a41a090131f8478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774009580fabfac34a41a090131f8478">&#9670;&#160;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::acos() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6caf5abc2a47bbaae2c6066d5c63b36" name="af6caf5abc2a47bbaae2c6066d5c63b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6caf5abc2a47bbaae2c6066d5c63b36">&#9670;&#160;</a></span>allocate_intrusive_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslp_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt; slp::allocate_intrusive_shared </td>
          <td>(</td>
          <td class="paramtype">Alloc</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in an intrusive shared pointer using alloc as the storage allocator of T and args as the parameter list for the constructor of T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object for intrusive shared pointer. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of allocator for T. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator for T. </td></tr>
    <tr><td class="paramname">args</td><td>Constructor arguments for T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7b5654b815b14e62635753fbd5ae89e" name="af7b5654b815b14e62635753fbd5ae89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b5654b815b14e62635753fbd5ae89e">&#9670;&#160;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::asin() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa270ed7812f41d90f66faa3115d456b" name="aaa270ed7812f41d90f66faa3115d456b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa270ed7812f41d90f66faa3115d456b">&#9670;&#160;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::atan() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae44cd61021fb547d9c17b3122dd59da3" name="ae44cd61021fb547d9c17b3122dd59da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44cd61021fb547d9c17b3122dd59da3">&#9670;&#160;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::atan2() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e0b599c59a55393611074e3021a3cc" name="ae7e0b599c59a55393611074e3021a3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0b599c59a55393611074e3021a3cc">&#9670;&#160;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> slp::block </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assemble a <a class="el" href="classslp_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks. </p>
<p>Each row's blocks must have the same height, and the assembled block rows must have the same width. For example, for the block matrix [[A, B], [C]] to be constructible, the number of rows in A and B must match, and the number of columns in [A, B] and [C] must match.</p>
<p>This overload is for Python bindings only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The nested list of blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b2c23a77996d1f30972aa5221b5bfd6" name="a7b2c23a77996d1f30972aa5221b5bfd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2c23a77996d1f30972aa5221b5bfd6">&#9670;&#160;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> slp::block </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assemble a <a class="el" href="classslp_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> from a nested list of blocks. </p>
<p>Each row's blocks must have the same height, and the assembled block rows must have the same width. For example, for the block matrix [[A, B], [C]] to be constructible, the number of rows in A and B must match, and the number of columns in [A, B] and [C] must match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The nested list of blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57119646ec2486451072a66c2e4f7738" name="a57119646ec2486451072a66c2e4f7738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57119646ec2486451072a66c2e4f7738">&#9670;&#160;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::cos() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7f161616808a05ed7355021bc556a01" name="af7f161616808a05ed7355021bc556a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f161616808a05ed7355021bc556a01">&#9670;&#160;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::cosh() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e3205b1e0e0b15032292bec51c3fbef" name="a3e3205b1e0e0b15032292bec51c3fbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3205b1e0e0b15032292bec51c3fbef">&#9670;&#160;</a></span>cwise_reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> slp::cwise_reduce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="classslp_1_1_variable.html">Variable</a>(const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;x, const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;y)&gt;</td>          <td class="paramname"><span class="paramname"><em>binary_op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a coefficient-wise reduce operation to two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side of the binary operator. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side of the binary operator. </td></tr>
    <tr><td class="paramname">binary_op</td><td>The binary operator to use for the reduce operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb7643e4c231e598b4b598a6e327558" name="a5fb7643e4c231e598b4b598a6e327558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb7643e4c231e598b4b598a6e327558">&#9670;&#160;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::erf() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5922753b1dda05845148abf3daf50421" name="a5922753b1dda05845148abf3daf50421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5922753b1dda05845148abf3daf50421">&#9670;&#160;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::exp() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1815b06747ce45e267e8813c6d572f1" name="aa1815b06747ce45e267e8813c6d572f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1815b06747ce45e267e8813c6d572f1">&#9670;&#160;</a></span>function_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">slp::function_ref </td>
          <td>(</td>
          <td class="paramtype">R(*</td>          <td class="paramname"><span class="paramname"><em>&#160;</em></span>)(Args...)</td><td>)</td>
          <td> -&gt;  function_ref&lt; R(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c44aad43ff9dc2c68f559d7e218f55e" name="a7c44aad43ff9dc2c68f559d7e218f55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c44aad43ff9dc2c68f559d7e218f55e">&#9670;&#160;</a></span>global_pool_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslp_1_1_pool_allocator.html">PoolAllocator</a>&lt; T &gt; slp::global_pool_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an allocator for a global pool memory resource. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a459659bbeb1a517d714747b03925cc85" name="a459659bbeb1a517d714747b03925cc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459659bbeb1a517d714747b03925cc85">&#9670;&#160;</a></span>global_pool_resource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_pool_resource.html">PoolResource</a> &amp; slp::global_pool_resource </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a global pool memory resource. </p>

</div>
</div>
<a id="ad5e175f8f0059c17072fbabc1a5e5d4c" name="ad5e175f8f0059c17072fbabc1a5e5d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e175f8f0059c17072fbabc1a5e5d4c">&#9670;&#160;</a></span>hypot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::hypot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::hypot() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e232ce5a84b56836ea900469e100033" name="a7e232ce5a84b56836ea900469e100033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e232ce5a84b56836ea900469e100033">&#9670;&#160;</a></span>hypot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::hypot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::hypot() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x argument. </td></tr>
    <tr><td class="paramname">y</td><td>The y argument. </td></tr>
    <tr><td class="paramname">z</td><td>The z argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fa2a313c44bd67df8044c72c432a86c" name="a6fa2a313c44bd67df8044c72c432a86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa2a313c44bd67df8044c72c432a86c">&#9670;&#160;</a></span>interior_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a> slp::interior_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_interior_point_matrix_callbacks.html">InteriorPointMatrixCallbacks</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix_callbacks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; std::function&lt; bool(const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a> &amp;info)&gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>iteration_callbacks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the optimal solution to a nonlinear program using the interior-point method. </p>
<p>A nonlinear program has the form:</p>
<pre class="fragment">     min_x f(x)
subject to cₑ(x) = 0
           cᵢ(x) ≥ 0
</pre><p>where f(x) is the cost function, cₑ(x) are the equality constraints, and cᵢ(x) are the inequality constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_callbacks</td><td>Matrix callbacks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration_callbacks</td><td>The list of callbacks to call at the beginning of each iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Solver options. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The initial guess and output location for the decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exit status. </dd></dl>

</div>
</div>
<a id="a8a23cba26b0af9d17aa04f39e0dfd724" name="a8a23cba26b0af9d17aa04f39e0dfd724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a23cba26b0af9d17aa04f39e0dfd724">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::log() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a570974539fd17ffe5726129b3908996f" name="a570974539fd17ffe5726129b3908996f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570974539fd17ffe5726129b3908996f">&#9670;&#160;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::log10() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53ec38186afb059f74cba282454ef347" name="a53ec38186afb059f74cba282454ef347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ec38186afb059f74cba282454ef347">&#9670;&#160;</a></span>make_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegch.html#ad37c85689071b4ba65fc5e4155432d1b">gch::small_vector</a>&lt; <a class="el" href="classslp_1_1_variable.html">Variable</a> &gt; slp::make_constraints </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a list of constraints. </p>
<p>The standard form for equality constraints is c(x) = 0, and the standard form for inequality constraints is c(x) ≥ 0. This function takes constraints of the form lhs = rhs or lhs ≥ rhs and converts them to lhs - rhs = 0 or lhs - rhs ≥ 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3300a70171412c36cb32d88e64f2456a" name="a3300a70171412c36cb32d88e64f2456a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3300a70171412c36cb32d88e64f2456a">&#9670;&#160;</a></span>make_intrusive_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslp_1_1_intrusive_shared_ptr.html">IntrusiveSharedPtr</a>&lt; T &gt; slp::make_intrusive_shared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type T and wraps it in an intrusive shared pointer using args as the parameter list for the constructor of T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object for intrusive shared pointer. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments for T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8c65b2c9d67bcc9e69e7287a59d6e12" name="ad8c65b2c9d67bcc9e69e7287a59d6e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c65b2c9d67bcc9e69e7287a59d6e12">&#9670;&#160;</a></span>Multistart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DecisionVariables &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslp_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt; slp::Multistart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; <a class="el" href="structslp_1_1_multistart_result.html">MultistartResult</a>&lt; DecisionVariables &gt;(const DecisionVariables &amp;initial_guess)&gt;</td>          <td class="paramname"><span class="paramname"><em>solve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const DecisionVariables &gt;</td>          <td class="paramname"><span class="paramname"><em>initial_guesses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization problem from different starting points in parallel, then returns the solution with the lowest cost. </p>
<p>Each solve is performed on a separate thread. Solutions from successful solves are always preferred over solutions from unsuccessful solves, and cost (lower is better) is the tiebreaker between successful solves.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DecisionVariables</td><td>The type containing the decision variable initial guess. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solve</td><td>A user-provided function that takes a decision variable initial guess and returns a <a class="el" href="structslp_1_1_multistart_result.html" title="The result of a multistart solve.">MultistartResult</a>. </td></tr>
    <tr><td class="paramname">initial_guesses</td><td>A list of decision variable initial guesses to try. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e0df3801bb4a3e3d4bbacf11fd7b961" name="a4e0df3801bb4a3e3d4bbacf11fd7b961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0df3801bb4a3e3d4bbacf11fd7b961">&#9670;&#160;</a></span>newton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a> slp::newton </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_newton_matrix_callbacks.html">NewtonMatrixCallbacks</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix_callbacks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; std::function&lt; bool(const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a> &amp;info)&gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>iteration_callbacks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the optimal solution to a nonlinear program using Newton's method. </p>
<p>A nonlinear program has the form:</p>
<pre class="fragment">     min_x f(x)
</pre><p>where f(x) is the cost function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_callbacks</td><td>Matrix callbacks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration_callbacks</td><td>The list of callbacks to call at the beginning of each iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Solver options. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The initial guess and output location for the decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exit status. </dd></dl>

</div>
</div>
<a id="a3b54f84df8d23b6950a6d836ef7d3fac" name="a3b54f84df8d23b6950a6d836ef7d3fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b54f84df8d23b6950a6d836ef7d3fac">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> slp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a258dff8f72ecfcaea32462232a6a49c0" name="a258dff8f72ecfcaea32462232a6a49c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258dff8f72ecfcaea32462232a6a49c0">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> slp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than-or-equal-to comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9b3718a060eb2cba0fe57ac1d8ac3fd" name="ae9b3718a060eb2cba0fe57ac1d8ac3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b3718a060eb2cba0fe57ac1d8ac3fd">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslp_1_1_equality_constraints.html">EqualityConstraints</a> slp::operator== </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator that returns an equality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c05891cc49fcf3b65e50b6e8a1122a4" name="a4c05891cc49fcf3b65e50b6e8a1122a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c05891cc49fcf3b65e50b6e8a1122a4">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> slp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38b95786e1e148a77c398dbaa9f35bfd" name="a38b95786e1e148a77c398dbaa9f35bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b95786e1e148a77c398dbaa9f35bfd">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LHS , typename RHS &gt; <br />
requires (ScalarLike&lt;LHS&gt; || MatrixLike&lt;LHS&gt;) &amp;&amp; (ScalarLike&lt;RHS&gt; || MatrixLike&lt;RHS&gt;) &amp;&amp; (SleipnirType&lt;LHS&gt; || SleipnirType&lt;RHS&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> slp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">LHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greater-than-or-equal-to comparison operator that returns an inequality constraint for two Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side. </td></tr>
    <tr><td class="paramname">rhs</td><td>Left-hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b3d5a31cac3cfdb934951aec05e1539" name="a7b3d5a31cac3cfdb934951aec05e1539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3d5a31cac3cfdb934951aec05e1539">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>power</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::pow() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base. </td></tr>
    <tr><td class="paramname">power</td><td>The power. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addf0981a979a0c79a3319f76ff5584c8" name="addf0981a979a0c79a3319f76ff5584c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf0981a979a0c79a3319f76ff5584c8">&#9670;&#160;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::print </td>
          <td>(</td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::print() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a98c88ae28619e062683faff1ab21740a" name="a98c88ae28619e062683faff1ab21740a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c88ae28619e062683faff1ab21740a">&#9670;&#160;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::print </td>
          <td>(</td>
          <td class="paramtype">std::FILE *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::print() that squelches write failure exceptions. </p>

</div>
</div>
<a id="ac564720b4a398578532f97682ecf39c6" name="ac564720b4a398578532f97682ecf39c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac564720b4a398578532f97682ecf39c6">&#9670;&#160;</a></span>println() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::println </td>
          <td>(</td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::println() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a979c7cfc5ade9d54b85e81dd6deb6410" name="a979c7cfc5ade9d54b85e81dd6deb6410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979c7cfc5ade9d54b85e81dd6deb6410">&#9670;&#160;</a></span>println() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::println </td>
          <td>(</td>
          <td class="paramtype">std::FILE *</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmt::format_string&lt; T... &gt;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around fmt::println() that squelches write failure exceptions. </p>

</div>
</div>
<a id="a0c35bde4490817185cdde27e2b2694fb" name="a0c35bde4490817185cdde27e2b2694fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c35bde4490817185cdde27e2b2694fb">&#9670;&#160;</a></span>rk4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename State , typename Input , typename Time &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">State slp::rk4 </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">State</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time</td>          <td class="paramname"><span class="paramname"><em>t0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs 4th order Runge-Kutta integration of dx/dt = f(t, x, u) for dt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to integrate. It must take two arguments x and u. </td></tr>
    <tr><td class="paramname">x</td><td>The initial value of x. </td></tr>
    <tr><td class="paramname">u</td><td>The value u held constant over the integration period. </td></tr>
    <tr><td class="paramname">t0</td><td>The initial time. </td></tr>
    <tr><td class="paramname">dt</td><td>The time over which to integrate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4beb6cf56fadafd356ad218ccd123828" name="a4beb6cf56fadafd356ad218ccd123828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beb6cf56fadafd356ad218ccd123828">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::sign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="wpiutil_2src_2main_2native_2thirdparty_2fmtlib_2include_2fmt_2base_8h.html#a8c33592060c5e5568b3fa116c71610ba">sign()</a> for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef1a0468d96ccf9b7e84fef2fc5bbe7" name="aeef1a0468d96ccf9b7e84fef2fc5bbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef1a0468d96ccf9b7e84fef2fc5bbe7">&#9670;&#160;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::sin() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33561e28e36d46c2d60a8d178f087e26" name="a33561e28e36d46c2d60a8d178f087e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33561e28e36d46c2d60a8d178f087e26">&#9670;&#160;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::sinh() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a5fa16d9f5b98cd9a0f0805c8e3c85e" name="a9a5fa16d9f5b98cd9a0f0805c8e3c85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5fa16d9f5b98cd9a0f0805c8e3c85e">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> slp::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the <a class="el" href="classslp_1_1_variable_matrix.html" title="A matrix of autodiff variables.">VariableMatrix</a> equation AX = B for X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The left-hand side. </td></tr>
    <tr><td class="paramname">B</td><td>The right-hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The solution X. </dd></dl>

</div>
</div>
<a id="a608284d0d03f8be8f1911648657aa141" name="a608284d0d03f8be8f1911648657aa141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608284d0d03f8be8f1911648657aa141">&#9670;&#160;</a></span>sqp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a> slp::sqp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_s_q_p_matrix_callbacks.html">SQPMatrixCallbacks</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix_callbacks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; std::function&lt; bool(const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a> &amp;info)&gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>iteration_callbacks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the optimal solution to a nonlinear program using Sequential Quadratic Programming (SQP). </p>
<p>A nonlinear program has the form:</p>
<pre class="fragment">     min_x f(x)
subject to cₑ(x) = 0
</pre><p>where f(x) is the cost function and cₑ(x) are the equality constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_callbacks</td><td>Matrix callbacks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iteration_callbacks</td><td>The list of callbacks to call at the beginning of each iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Solver options. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The initial guess and output location for the decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exit status. </dd></dl>

</div>
</div>
<a id="aa62d8c27a23e3a845d35092229e447a5" name="aa62d8c27a23e3a845d35092229e447a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62d8c27a23e3a845d35092229e447a5">&#9670;&#160;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::sqrt() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5b30d031a2664632fa0682f1519d5e8" name="ae5b30d031a2664632fa0682f1519d5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b30d031a2664632fa0682f1519d5e8">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classslp_1_1function__ref.html">function_ref</a>&lt; R(Args...)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the referred callables of <code>lhs</code> and <code>rhs</code>. </p>

</div>
</div>
<a id="a513e317c681e1dda3e370f838785e53e" name="a513e317c681e1dda3e370f838785e53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513e317c681e1dda3e370f838785e53e">&#9670;&#160;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::tan() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced20c253142e62c84e6cde3d3779aa7" name="aced20c253142e62c84e6cde3d3779aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced20c253142e62c84e6cde3d3779aa7">&#9670;&#160;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> <a class="el" href="classslp_1_1_variable.html">Variable</a> slp::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::tanh() for Variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992ddea754700b70b528b6e035ec7905" name="a992ddea754700b70b528b6e035ec7905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992ddea754700b70b528b6e035ec7905">&#9670;&#160;</a></span>to_message() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr std::string_view slp::to_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>exit_status</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns user-readable message corresponding to the solver exit status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exit_status</td><td>Solver exit status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11876ec2872473641550f1b4b461baf2" name="a11876ec2872473641550f1b4b461baf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11876ec2872473641550f1b4b461baf2">&#9670;&#160;</a></span>to_message() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> constexpr std::string_view slp::to_message </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns user-readable message corresponding to the expression type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Expression type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7fa06f348bbf7df69e2780efa1e157fb" name="a7fa06f348bbf7df69e2780efa1e157fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa06f348bbf7df69e2780efa1e157fb">&#9670;&#160;</a></span>Hessian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int UpLo = Eigen::Lower | Eigen::Upper&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> slp::Hessian</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2baa5511d10c78d3b75925f032613ced" name="a2baa5511d10c78d3b75925f032613ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2baa5511d10c78d3b75925f032613ced">&#9670;&#160;</a></span>Jacobian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="symbol__exports_8hpp.html#adf5655e62968171c7db7f8ffafe8e15b">SLEIPNIR_DLLEXPORT</a> slp::Jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceslp.html">slp</a></li>
    <li class="footer">Generated on Sat May 31 2025 13:41:24 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
