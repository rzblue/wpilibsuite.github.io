<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: wpi::StringMap&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.3.2-54-g7a3df61</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classwpi_1_1_string_map.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classwpi_1_1_string_map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">wpi::StringMap&lt; T, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classwpi_1_1_string_map.html" title="StringMap is a sorted associative container that contains key-value pairs with unique string keys.">StringMap</a> is a sorted associative container that contains key-value pairs with unique string keys.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_string_map_8h_source.html">wpi/StringMap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wpi::StringMap&lt; T, Allocator &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classwpi_1_1_string_map.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0e697b9a561e6a561fe8415b058eeaad" id="r_a0e697b9a561e6a561fe8415b058eeaad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e697b9a561e6a561fe8415b058eeaad">map_type</a> = typename std::map&lt;std::string, T, std::less&lt;&gt;&gt;</td></tr>
<tr class="separator:a0e697b9a561e6a561fe8415b058eeaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5717c96cd024a4273f7c801eaa4db9" id="r_a1a5717c96cd024a4273f7c801eaa4db9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a5717c96cd024a4273f7c801eaa4db9">key_type</a> = typename map_type::key_type</td></tr>
<tr class="separator:a1a5717c96cd024a4273f7c801eaa4db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fb4f0725254e1d9e1857075e0eb790" id="r_a40fb4f0725254e1d9e1857075e0eb790"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40fb4f0725254e1d9e1857075e0eb790">mapped_type</a> = typename map_type::mapped_type</td></tr>
<tr class="separator:a40fb4f0725254e1d9e1857075e0eb790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2297b050fce50cbd1dfec95c22e50c06" id="r_a2297b050fce50cbd1dfec95c22e50c06"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2297b050fce50cbd1dfec95c22e50c06">value_type</a> = typename map_type::value_type</td></tr>
<tr class="separator:a2297b050fce50cbd1dfec95c22e50c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1153934dc8ee2991f3deace8b7cac8dc" id="r_a1153934dc8ee2991f3deace8b7cac8dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1153934dc8ee2991f3deace8b7cac8dc">size_type</a> = typename map_type::size_type</td></tr>
<tr class="separator:a1153934dc8ee2991f3deace8b7cac8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39ba47cd91938bee4693479109ec62a" id="r_ad39ba47cd91938bee4693479109ec62a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39ba47cd91938bee4693479109ec62a">difference_type</a> = typename map_type::difference_type</td></tr>
<tr class="separator:ad39ba47cd91938bee4693479109ec62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58305bc8d84d88ed38081e7d3d92b297" id="r_a58305bc8d84d88ed38081e7d3d92b297"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58305bc8d84d88ed38081e7d3d92b297">key_compare</a> = typename map_type::key_compare</td></tr>
<tr class="separator:a58305bc8d84d88ed38081e7d3d92b297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e7f0f4ba2ae136a5cc870664c78498" id="r_a75e7f0f4ba2ae136a5cc870664c78498"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75e7f0f4ba2ae136a5cc870664c78498">allocator_type</a> = typename map_type::allocator_type</td></tr>
<tr class="separator:a75e7f0f4ba2ae136a5cc870664c78498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a3185f0656d428ea3c294f8c666cf" id="r_ac70a3185f0656d428ea3c294f8c666cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac70a3185f0656d428ea3c294f8c666cf">reference</a> = typename map_type::reference</td></tr>
<tr class="separator:ac70a3185f0656d428ea3c294f8c666cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa19f42ffdcaaf8518af4c75e38b6f3a" id="r_afa19f42ffdcaaf8518af4c75e38b6f3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa19f42ffdcaaf8518af4c75e38b6f3a">const_reference</a> = typename map_type::const_reference</td></tr>
<tr class="separator:afa19f42ffdcaaf8518af4c75e38b6f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b50a9ae2be0e0957492d0556b74081" id="r_ae8b50a9ae2be0e0957492d0556b74081"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8b50a9ae2be0e0957492d0556b74081">pointer</a> = typename map_type::pointer</td></tr>
<tr class="separator:ae8b50a9ae2be0e0957492d0556b74081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bdee155cacf291566d37ec6d93fa1a" id="r_a62bdee155cacf291566d37ec6d93fa1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62bdee155cacf291566d37ec6d93fa1a">const_pointer</a> = typename map_type::const_pointer</td></tr>
<tr class="separator:a62bdee155cacf291566d37ec6d93fa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25fd3a556c507e72a1795b8e3fd4cf0" id="r_af25fd3a556c507e72a1795b8e3fd4cf0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> = typename map_type::iterator</td></tr>
<tr class="separator:af25fd3a556c507e72a1795b8e3fd4cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac373b8ae667f88ea953176906cf2ec06" id="r_ac373b8ae667f88ea953176906cf2ec06"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> = typename map_type::const_iterator</td></tr>
<tr class="separator:ac373b8ae667f88ea953176906cf2ec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0081ac98b9d52907df32a0f7fb7b4" id="r_aa1c0081ac98b9d52907df32a0f7fb7b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1c0081ac98b9d52907df32a0f7fb7b4">reverse_iterator</a> = typename map_type::reverse_iterator</td></tr>
<tr class="separator:aa1c0081ac98b9d52907df32a0f7fb7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af468e853e8780708dc4eca4f1364adbd" id="r_af468e853e8780708dc4eca4f1364adbd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af468e853e8780708dc4eca4f1364adbd">const_reverse_iterator</a> = typename map_type::const_reverse_iterator</td></tr>
<tr class="separator:af468e853e8780708dc4eca4f1364adbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39e896c461bc832ee9665fa6df149e2" id="r_ab39e896c461bc832ee9665fa6df149e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab39e896c461bc832ee9665fa6df149e2">node_type</a> = typename map_type::node_type</td></tr>
<tr class="separator:ab39e896c461bc832ee9665fa6df149e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3883819fe63a3e7fc0168632acb0041" id="r_aa3883819fe63a3e7fc0168632acb0041"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3883819fe63a3e7fc0168632acb0041">insert_return_type</a> = typename map_type::insert_return_type</td></tr>
<tr class="separator:aa3883819fe63a3e7fc0168632acb0041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b451f83186f868ad7cd410579cfc1b2" id="r_a1b451f83186f868ad7cd410579cfc1b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b451f83186f868ad7cd410579cfc1b2">StringMap</a> ()=default</td></tr>
<tr class="memdesc:a1b451f83186f868ad7cd410579cfc1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container.  <br /></td></tr>
<tr class="separator:a1b451f83186f868ad7cd410579cfc1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159502e55478533c72943d07dd96cb19" id="r_a159502e55478533c72943d07dd96cb19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a159502e55478533c72943d07dd96cb19">StringMap</a> (const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a159502e55478533c72943d07dd96cb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty container.  <br /></td></tr>
<tr class="separator:a159502e55478533c72943d07dd96cb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa91c778a2aa6ba6e8d284a1c300c11" id="r_a6aa91c778a2aa6ba6e8d284a1c300c11"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:a6aa91c778a2aa6ba6e8d284a1c300c11"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6aa91c778a2aa6ba6e8d284a1c300c11">StringMap</a> (InputIt first, InputIt last, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a6aa91c778a2aa6ba6e8d284a1c300c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <br /></td></tr>
<tr class="separator:a6aa91c778a2aa6ba6e8d284a1c300c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f41574b57e704f944d925fd2fb6da70" id="r_a0f41574b57e704f944d925fd2fb6da70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f41574b57e704f944d925fd2fb6da70">StringMap</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;)=default</td></tr>
<tr class="memdesc:a0f41574b57e704f944d925fd2fb6da70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a0f41574b57e704f944d925fd2fb6da70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37d4bea8d3ab483675b1026035ce3ae" id="r_ab37d4bea8d3ab483675b1026035ce3ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37d4bea8d3ab483675b1026035ce3ae">StringMap</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:ab37d4bea8d3ab483675b1026035ce3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:ab37d4bea8d3ab483675b1026035ce3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4053b534ba013066af6451c5881030" id="r_a8b4053b534ba013066af6451c5881030"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4053b534ba013066af6451c5881030">StringMap</a> (<a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a8b4053b534ba013066af6451c5881030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a8b4053b534ba013066af6451c5881030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8103d249b61e4a9a1f31a220ea18b9e3" id="r_a8103d249b61e4a9a1f31a220ea18b9e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8103d249b61e4a9a1f31a220ea18b9e3">StringMap</a> (<a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;&amp;other, const Allocator &amp;alloc)</td></tr>
<tr class="memdesc:a8103d249b61e4a9a1f31a220ea18b9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a8103d249b61e4a9a1f31a220ea18b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22f9b763eb8e2e516d20e1f7f282a9" id="r_aff22f9b763eb8e2e516d20e1f7f282a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff22f9b763eb8e2e516d20e1f7f282a9">StringMap</a> (std::initializer_list&lt; <a class="el" href="#a2297b050fce50cbd1dfec95c22e50c06">value_type</a> &gt; init, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:aff22f9b763eb8e2e516d20e1f7f282a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor.  <br /></td></tr>
<tr class="separator:aff22f9b763eb8e2e516d20e1f7f282a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bea7224513973f54413eb19fe3258b5" id="r_a7bea7224513973f54413eb19fe3258b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bea7224513973f54413eb19fe3258b5">operator=</a> (const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;)=default</td></tr>
<tr class="memdesc:a7bea7224513973f54413eb19fe3258b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a7bea7224513973f54413eb19fe3258b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dc3fda45dbdf614e047dc187b480b2" id="r_a01dc3fda45dbdf614e047dc187b480b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01dc3fda45dbdf614e047dc187b480b2">operator=</a> (<a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;&amp;) noexcept(std::allocator_traits&lt; Allocator &gt;::is_always_equal::value &amp;&amp;std::is_nothrow_move_assignable&lt; std::less&lt;&gt; &gt;::value)=default</td></tr>
<tr class="memdesc:a01dc3fda45dbdf614e047dc187b480b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a01dc3fda45dbdf614e047dc187b480b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a808c6d70d723a7e09944ca290cfaee" id="r_a2a808c6d70d723a7e09944ca290cfaee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a808c6d70d723a7e09944ca290cfaee">operator=</a> (std::initializer_list&lt; <a class="el" href="#a2297b050fce50cbd1dfec95c22e50c06">value_type</a> &gt; ilist)</td></tr>
<tr class="memdesc:a2a808c6d70d723a7e09944ca290cfaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with those identified by initializer list ilist.  <br /></td></tr>
<tr class="separator:a2a808c6d70d723a7e09944ca290cfaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915a2e8d216b771929fe54e7eae8a68c" id="r_a915a2e8d216b771929fe54e7eae8a68c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a915a2e8d216b771929fe54e7eae8a68c">at</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a915a2e8d216b771929fe54e7eae8a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with the specified key.  <br /></td></tr>
<tr class="separator:a915a2e8d216b771929fe54e7eae8a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66f7ea1bb8cf31d77d51a6302125d0" id="r_a7e66f7ea1bb8cf31d77d51a6302125d0"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e66f7ea1bb8cf31d77d51a6302125d0">at</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a7e66f7ea1bb8cf31d77d51a6302125d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with the specified key.  <br /></td></tr>
<tr class="separator:a7e66f7ea1bb8cf31d77d51a6302125d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e4c5eeb77c39b1b7e78fb66b391778" id="r_a54e4c5eeb77c39b1b7e78fb66b391778"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54e4c5eeb77c39b1b7e78fb66b391778">at</a> (const char *key)</td></tr>
<tr class="memdesc:a54e4c5eeb77c39b1b7e78fb66b391778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with the specified key.  <br /></td></tr>
<tr class="separator:a54e4c5eeb77c39b1b7e78fb66b391778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01858aeb0ed53c9c3d2c69924ce81236" id="r_a01858aeb0ed53c9c3d2c69924ce81236"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01858aeb0ed53c9c3d2c69924ce81236">at</a> (const char *key) const</td></tr>
<tr class="memdesc:a01858aeb0ed53c9c3d2c69924ce81236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with the specified key.  <br /></td></tr>
<tr class="separator:a01858aeb0ed53c9c3d2c69924ce81236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069733f0cf4b1b14a36a18d50e7f7328" id="r_a069733f0cf4b1b14a36a18d50e7f7328"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a069733f0cf4b1b14a36a18d50e7f7328">at</a> (std::string_view key)</td></tr>
<tr class="memdesc:a069733f0cf4b1b14a36a18d50e7f7328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with the specified key.  <br /></td></tr>
<tr class="separator:a069733f0cf4b1b14a36a18d50e7f7328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd232068fce36e1e608e92b38b36cde3" id="r_afd232068fce36e1e608e92b38b36cde3"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd232068fce36e1e608e92b38b36cde3">at</a> (std::string_view key) const</td></tr>
<tr class="memdesc:afd232068fce36e1e608e92b38b36cde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the mapped value of the element with the specified key.  <br /></td></tr>
<tr class="separator:afd232068fce36e1e608e92b38b36cde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08660fd40faa7026744fb4ca23dfe4c7" id="r_a08660fd40faa7026744fb4ca23dfe4c7"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08660fd40faa7026744fb4ca23dfe4c7">operator[]</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:a08660fd40faa7026744fb4ca23dfe4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist.  <br /></td></tr>
<tr class="separator:a08660fd40faa7026744fb4ca23dfe4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8355450eef9ca122b30b1c29f527da" id="r_aaa8355450eef9ca122b30b1c29f527da"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa8355450eef9ca122b30b1c29f527da">operator[]</a> (std::string &amp;&amp;key)</td></tr>
<tr class="memdesc:aaa8355450eef9ca122b30b1c29f527da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist.  <br /></td></tr>
<tr class="separator:aaa8355450eef9ca122b30b1c29f527da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6353a713a25a5d347b805c1312c54" id="r_a68d6353a713a25a5d347b805c1312c54"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68d6353a713a25a5d347b805c1312c54">operator[]</a> (const char *key)</td></tr>
<tr class="memdesc:a68d6353a713a25a5d347b805c1312c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist.  <br /></td></tr>
<tr class="separator:a68d6353a713a25a5d347b805c1312c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29c70d30572d10219368c20b87a1c51" id="r_ac29c70d30572d10219368c20b87a1c51"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29c70d30572d10219368c20b87a1c51">operator[]</a> (std::string_view key)</td></tr>
<tr class="memdesc:ac29c70d30572d10219368c20b87a1c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist.  <br /></td></tr>
<tr class="separator:ac29c70d30572d10219368c20b87a1c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990d6ef716e0c6f15b9387d2f0aee32f" id="r_a990d6ef716e0c6f15b9387d2f0aee32f"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a990d6ef716e0c6f15b9387d2f0aee32f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a990d6ef716e0c6f15b9387d2f0aee32f">insert_or_assign</a> (std::string &amp;&amp;key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a990d6ef716e0c6f15b9387d2f0aee32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key.  <br /></td></tr>
<tr class="separator:a990d6ef716e0c6f15b9387d2f0aee32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299b66e17bfe13a5bfb713ff97bae65c" id="r_a299b66e17bfe13a5bfb713ff97bae65c"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a299b66e17bfe13a5bfb713ff97bae65c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a299b66e17bfe13a5bfb713ff97bae65c">insert_or_assign</a> (const char *key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a299b66e17bfe13a5bfb713ff97bae65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key.  <br /></td></tr>
<tr class="separator:a299b66e17bfe13a5bfb713ff97bae65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395ebba5835c6ca63f6b7bbc0efe3baf" id="r_a395ebba5835c6ca63f6b7bbc0efe3baf"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a395ebba5835c6ca63f6b7bbc0efe3baf"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a395ebba5835c6ca63f6b7bbc0efe3baf">insert_or_assign</a> (std::string_view key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a395ebba5835c6ca63f6b7bbc0efe3baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key.  <br /></td></tr>
<tr class="separator:a395ebba5835c6ca63f6b7bbc0efe3baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c3a78f547f3e2508edad6a2b7eb912" id="r_ab8c3a78f547f3e2508edad6a2b7eb912"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ab8c3a78f547f3e2508edad6a2b7eb912"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8c3a78f547f3e2508edad6a2b7eb912">insert_or_assign</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> hint, std::string &amp;&amp;key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:ab8c3a78f547f3e2508edad6a2b7eb912"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key.  <br /></td></tr>
<tr class="separator:ab8c3a78f547f3e2508edad6a2b7eb912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01302fd57712a78773df96b05d0631de" id="r_a01302fd57712a78773df96b05d0631de"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a01302fd57712a78773df96b05d0631de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01302fd57712a78773df96b05d0631de">insert_or_assign</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> hint, const char *key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a01302fd57712a78773df96b05d0631de"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key.  <br /></td></tr>
<tr class="separator:a01302fd57712a78773df96b05d0631de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c31674898df47e49229700591e3b904" id="r_a5c31674898df47e49229700591e3b904"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a5c31674898df47e49229700591e3b904"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c31674898df47e49229700591e3b904">insert_or_assign</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> hint, std::string_view key, M &amp;&amp;obj)</td></tr>
<tr class="memdesc:a5c31674898df47e49229700591e3b904"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key.  <br /></td></tr>
<tr class="separator:a5c31674898df47e49229700591e3b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3b037272895b00ff6045e9e4025e5" id="r_ae9a3b037272895b00ff6045e9e4025e5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae9a3b037272895b00ff6045e9e4025e5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae9a3b037272895b00ff6045e9e4025e5">emplace</a> (std::string &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae9a3b037272895b00ff6045e9e4025e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container.  <br /></td></tr>
<tr class="separator:ae9a3b037272895b00ff6045e9e4025e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed033547d911c826480115b302eff77f" id="r_aed033547d911c826480115b302eff77f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aed033547d911c826480115b302eff77f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aed033547d911c826480115b302eff77f">emplace</a> (const char *key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aed033547d911c826480115b302eff77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container.  <br /></td></tr>
<tr class="separator:aed033547d911c826480115b302eff77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8802c911f7128c7362ab0f6f65208f70" id="r_a8802c911f7128c7362ab0f6f65208f70"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8802c911f7128c7362ab0f6f65208f70"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8802c911f7128c7362ab0f6f65208f70">emplace</a> (std::string_view key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8802c911f7128c7362ab0f6f65208f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container.  <br /></td></tr>
<tr class="separator:a8802c911f7128c7362ab0f6f65208f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc35740db20d45109f32670992f5341" id="r_acfc35740db20d45109f32670992f5341"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acfc35740db20d45109f32670992f5341"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acfc35740db20d45109f32670992f5341">try_emplace</a> (std::string &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acfc35740db20d45109f32670992f5341"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, does nothing.  <br /></td></tr>
<tr class="separator:acfc35740db20d45109f32670992f5341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9de194dd108bb65a0a4c2a678c387a" id="r_a6a9de194dd108bb65a0a4c2a678c387a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6a9de194dd108bb65a0a4c2a678c387a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a9de194dd108bb65a0a4c2a678c387a">try_emplace</a> (const char *key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6a9de194dd108bb65a0a4c2a678c387a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, does nothing.  <br /></td></tr>
<tr class="separator:a6a9de194dd108bb65a0a4c2a678c387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c088e214e41b991b6b4a440634bd54" id="r_a42c088e214e41b991b6b4a440634bd54"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a42c088e214e41b991b6b4a440634bd54"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42c088e214e41b991b6b4a440634bd54">try_emplace</a> (std::string_view key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a42c088e214e41b991b6b4a440634bd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, does nothing.  <br /></td></tr>
<tr class="separator:a42c088e214e41b991b6b4a440634bd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46e95985135713b786095102c6b91e7" id="r_ab46e95985135713b786095102c6b91e7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab46e95985135713b786095102c6b91e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab46e95985135713b786095102c6b91e7">try_emplace</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> hint, std::string &amp;&amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab46e95985135713b786095102c6b91e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, does nothing.  <br /></td></tr>
<tr class="separator:ab46e95985135713b786095102c6b91e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15703bd0a9459b3e284617112eac91b" id="r_ad15703bd0a9459b3e284617112eac91b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad15703bd0a9459b3e284617112eac91b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad15703bd0a9459b3e284617112eac91b">try_emplace</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> hint, const char *key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad15703bd0a9459b3e284617112eac91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, does nothing.  <br /></td></tr>
<tr class="separator:ad15703bd0a9459b3e284617112eac91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25da22cdf2b8f4a2aee32e734d909472" id="r_a25da22cdf2b8f4a2aee32e734d909472"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a25da22cdf2b8f4a2aee32e734d909472"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a25da22cdf2b8f4a2aee32e734d909472">try_emplace</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> hint, std::string_view key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a25da22cdf2b8f4a2aee32e734d909472"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a key equal to key already exists in the container, does nothing.  <br /></td></tr>
<tr class="separator:a25da22cdf2b8f4a2aee32e734d909472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd79a05d779d7f6056502ff389f70f39" id="r_acd79a05d779d7f6056502ff389f70f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd79a05d779d7f6056502ff389f70f39">erase</a> (<a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> pos)</td></tr>
<tr class="memdesc:acd79a05d779d7f6056502ff389f70f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos.  <br /></td></tr>
<tr class="separator:acd79a05d779d7f6056502ff389f70f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb95c23c213c73efe78d6e701348edf" id="r_aafb95c23c213c73efe78d6e701348edf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafb95c23c213c73efe78d6e701348edf">erase</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> pos)</td></tr>
<tr class="memdesc:aafb95c23c213c73efe78d6e701348edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at pos.  <br /></td></tr>
<tr class="separator:aafb95c23c213c73efe78d6e701348edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b2f1c9392cdb97cc7b581497e94c20" id="r_ac2b2f1c9392cdb97cc7b581497e94c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2b2f1c9392cdb97cc7b581497e94c20">erase</a> (<a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> first, <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> last)</td></tr>
<tr class="memdesc:ac2b2f1c9392cdb97cc7b581497e94c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last), which must be a valid range in this.  <br /></td></tr>
<tr class="separator:ac2b2f1c9392cdb97cc7b581497e94c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6548500dcbb2050a7a7b174adfe32b18" id="r_a6548500dcbb2050a7a7b174adfe32b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6548500dcbb2050a7a7b174adfe32b18">erase</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> first, <a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> last)</td></tr>
<tr class="memdesc:a6548500dcbb2050a7a7b174adfe32b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last), which must be a valid range in this.  <br /></td></tr>
<tr class="separator:a6548500dcbb2050a7a7b174adfe32b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed59dee551b41503ce40ab38211fda10" id="r_aed59dee551b41503ce40ab38211fda10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1153934dc8ee2991f3deace8b7cac8dc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed59dee551b41503ce40ab38211fda10">erase</a> (std::string_view key)</td></tr>
<tr class="memdesc:aed59dee551b41503ce40ab38211fda10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element (if one exists) with the key equal to key.  <br /></td></tr>
<tr class="separator:aed59dee551b41503ce40ab38211fda10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdd9ebe17f1ee0ae836a83018c72b96" id="r_aefdd9ebe17f1ee0ae836a83018c72b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefdd9ebe17f1ee0ae836a83018c72b96">swap</a> (<a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp;other) noexcept(std::allocator_traits&lt; Allocator &gt;::is_always_equal::value &amp;&amp;std::is_nothrow_swappable&lt; std::less&lt;&gt; &gt;::value)</td></tr>
<tr class="memdesc:aefdd9ebe17f1ee0ae836a83018c72b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of other.  <br /></td></tr>
<tr class="separator:aefdd9ebe17f1ee0ae836a83018c72b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b9577f972e5299b7627acaa82ef3c" id="r_a275b9577f972e5299b7627acaa82ef3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab39e896c461bc832ee9665fa6df149e2">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a275b9577f972e5299b7627acaa82ef3c">extract</a> (<a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> position)</td></tr>
<tr class="memdesc:a275b9577f972e5299b7627acaa82ef3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the node that contains the element pointed to by position and returns a node handle that owns it.  <br /></td></tr>
<tr class="separator:a275b9577f972e5299b7627acaa82ef3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0858e1a5869ac9de0482f53fb72146" id="r_a0e0858e1a5869ac9de0482f53fb72146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab39e896c461bc832ee9665fa6df149e2">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e0858e1a5869ac9de0482f53fb72146">extract</a> (std::string_view key)</td></tr>
<tr class="memdesc:a0e0858e1a5869ac9de0482f53fb72146"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the container has an element with key equal to key, unlinks the node that contains that element from the container and returns a node handle that owns it.  <br /></td></tr>
<tr class="separator:a0e0858e1a5869ac9de0482f53fb72146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7a67758bffa7a31bda57186a3b17ee" id="r_a0b7a67758bffa7a31bda57186a3b17ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1153934dc8ee2991f3deace8b7cac8dc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7a67758bffa7a31bda57186a3b17ee">count</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a0b7a67758bffa7a31bda57186a3b17ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements with key that equals the specified argument.  <br /></td></tr>
<tr class="separator:a0b7a67758bffa7a31bda57186a3b17ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32b4dc3c432ee246667ea2f9eaf909f" id="r_af32b4dc3c432ee246667ea2f9eaf909f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af32b4dc3c432ee246667ea2f9eaf909f">find</a> (std::string_view key)</td></tr>
<tr class="memdesc:af32b4dc3c432ee246667ea2f9eaf909f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equal to key.  <br /></td></tr>
<tr class="separator:af32b4dc3c432ee246667ea2f9eaf909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8070535f81f1b69ef87d4523297ba647" id="r_a8070535f81f1b69ef87d4523297ba647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8070535f81f1b69ef87d4523297ba647">find</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a8070535f81f1b69ef87d4523297ba647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element with key equal to key.  <br /></td></tr>
<tr class="separator:a8070535f81f1b69ef87d4523297ba647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b47e972d36826e3b8c88cf031b6e002" id="r_a6b47e972d36826e3b8c88cf031b6e002"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b47e972d36826e3b8c88cf031b6e002">contains</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a6b47e972d36826e3b8c88cf031b6e002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is an element with key equal to key in the container.  <br /></td></tr>
<tr class="separator:a6b47e972d36826e3b8c88cf031b6e002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aea754578e5768be492b7e544c98175" id="r_a6aea754578e5768be492b7e544c98175"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aea754578e5768be492b7e544c98175">equal_range</a> (std::string_view key)</td></tr>
<tr class="memdesc:a6aea754578e5768be492b7e544c98175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <br /></td></tr>
<tr class="separator:a6aea754578e5768be492b7e544c98175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca08ddceb4909310d47823843abfc1d" id="r_afca08ddceb4909310d47823843abfc1d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a>, <a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afca08ddceb4909310d47823843abfc1d">equal_range</a> (std::string_view key) const</td></tr>
<tr class="memdesc:afca08ddceb4909310d47823843abfc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements with the given key in the container.  <br /></td></tr>
<tr class="separator:afca08ddceb4909310d47823843abfc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612eddd6b3f93b97557a7f56a3330f8" id="r_af612eddd6b3f93b97557a7f56a3330f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af612eddd6b3f93b97557a7f56a3330f8">lower_bound</a> (std::string_view key)</td></tr>
<tr class="memdesc:af612eddd6b3f93b97557a7f56a3330f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <br /></td></tr>
<tr class="separator:af612eddd6b3f93b97557a7f56a3330f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1542116fa94e27101c20c0487fea2f" id="r_a8b1542116fa94e27101c20c0487fea2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b1542116fa94e27101c20c0487fea2f">lower_bound</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a8b1542116fa94e27101c20c0487fea2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element that is not less than (i.e.  <br /></td></tr>
<tr class="separator:a8b1542116fa94e27101c20c0487fea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204e9fcce572f186dd0458ea6164a3db" id="r_a204e9fcce572f186dd0458ea6164a3db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a204e9fcce572f186dd0458ea6164a3db">upper_bound</a> (std::string_view key)</td></tr>
<tr class="memdesc:a204e9fcce572f186dd0458ea6164a3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interator pointing to the first element that is greater than key.  <br /></td></tr>
<tr class="separator:a204e9fcce572f186dd0458ea6164a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38071add9a6f14827f567b19b527e968" id="r_a38071add9a6f14827f567b19b527e968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38071add9a6f14827f567b19b527e968">upper_bound</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a38071add9a6f14827f567b19b527e968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interator pointing to the first element that is greater than key.  <br /></td></tr>
<tr class="separator:a38071add9a6f14827f567b19b527e968"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Allocator = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt;<br />
class wpi::StringMap&lt; T, Allocator &gt;</div><p><a class="el" href="classwpi_1_1_string_map.html" title="StringMap is a sorted associative container that contains key-value pairs with unique string keys.">StringMap</a> is a sorted associative container that contains key-value pairs with unique string keys. </p>
<p>Keys are sorted in the same order as std::string's are compared. Search, removal, and insertion operations have logarithmic complexity. The underlying implementation is std::map&lt;std::string, T&gt;. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a75e7f0f4ba2ae136a5cc870664c78498" name="a75e7f0f4ba2ae136a5cc870664c78498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e7f0f4ba2ae136a5cc870664c78498">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::allocator_type = typename map_type::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac373b8ae667f88ea953176906cf2ec06" name="ac373b8ae667f88ea953176906cf2ec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac373b8ae667f88ea953176906cf2ec06">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::const_iterator = typename map_type::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62bdee155cacf291566d37ec6d93fa1a" name="a62bdee155cacf291566d37ec6d93fa1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bdee155cacf291566d37ec6d93fa1a">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::const_pointer = typename map_type::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa19f42ffdcaaf8518af4c75e38b6f3a" name="afa19f42ffdcaaf8518af4c75e38b6f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa19f42ffdcaaf8518af4c75e38b6f3a">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::const_reference = typename map_type::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af468e853e8780708dc4eca4f1364adbd" name="af468e853e8780708dc4eca4f1364adbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af468e853e8780708dc4eca4f1364adbd">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::const_reverse_iterator = typename map_type::const_reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad39ba47cd91938bee4693479109ec62a" name="ad39ba47cd91938bee4693479109ec62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39ba47cd91938bee4693479109ec62a">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::difference_type = typename map_type::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3883819fe63a3e7fc0168632acb0041" name="aa3883819fe63a3e7fc0168632acb0041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3883819fe63a3e7fc0168632acb0041">&#9670;&#160;</a></span>insert_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::insert_return_type = typename map_type::insert_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af25fd3a556c507e72a1795b8e3fd4cf0" name="af25fd3a556c507e72a1795b8e3fd4cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25fd3a556c507e72a1795b8e3fd4cf0">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::iterator = typename map_type::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58305bc8d84d88ed38081e7d3d92b297" name="a58305bc8d84d88ed38081e7d3d92b297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58305bc8d84d88ed38081e7d3d92b297">&#9670;&#160;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::key_compare = typename map_type::key_compare</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a5717c96cd024a4273f7c801eaa4db9" name="a1a5717c96cd024a4273f7c801eaa4db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5717c96cd024a4273f7c801eaa4db9">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::key_type = typename map_type::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e697b9a561e6a561fe8415b058eeaad" name="a0e697b9a561e6a561fe8415b058eeaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e697b9a561e6a561fe8415b058eeaad">&#9670;&#160;</a></span>map_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::map_type = typename std::map&lt;std::string, T, std::less&lt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40fb4f0725254e1d9e1857075e0eb790" name="a40fb4f0725254e1d9e1857075e0eb790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fb4f0725254e1d9e1857075e0eb790">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::mapped_type = typename map_type::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab39e896c461bc832ee9665fa6df149e2" name="ab39e896c461bc832ee9665fa6df149e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39e896c461bc832ee9665fa6df149e2">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::node_type = typename map_type::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8b50a9ae2be0e0957492d0556b74081" name="ae8b50a9ae2be0e0957492d0556b74081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b50a9ae2be0e0957492d0556b74081">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::pointer = typename map_type::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac70a3185f0656d428ea3c294f8c666cf" name="ac70a3185f0656d428ea3c294f8c666cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70a3185f0656d428ea3c294f8c666cf">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::reference = typename map_type::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1c0081ac98b9d52907df32a0f7fb7b4" name="aa1c0081ac98b9d52907df32a0f7fb7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c0081ac98b9d52907df32a0f7fb7b4">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::reverse_iterator = typename map_type::reverse_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1153934dc8ee2991f3deace8b7cac8dc" name="a1153934dc8ee2991f3deace8b7cac8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153934dc8ee2991f3deace8b7cac8dc">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::size_type = typename map_type::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2297b050fce50cbd1dfec95c22e50c06" name="a2297b050fce50cbd1dfec95c22e50c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2297b050fce50cbd1dfec95c22e50c06">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::value_type = typename map_type::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b451f83186f868ad7cd410579cfc1b2" name="a1b451f83186f868ad7cd410579cfc1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b451f83186f868ad7cd410579cfc1b2">&#9670;&#160;</a></span>StringMap() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container. </p>

</div>
</div>
<a id="a159502e55478533c72943d07dd96cb19" name="a159502e55478533c72943d07dd96cb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159502e55478533c72943d07dd96cb19">&#9670;&#160;</a></span>StringMap() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aa91c778a2aa6ba6e8d284a1c300c11" name="a6aa91c778a2aa6ba6e8d284a1c300c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa91c778a2aa6ba6e8d284a1c300c11">&#9670;&#160;</a></span>StringMap() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted. If [first, last) is not a valid range, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of the range to copy the elements from </td></tr>
    <tr><td class="paramname">last</td><td>end of the range to copy the elements from </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f41574b57e704f944d925fd2fb6da70" name="a0f41574b57e704f944d925fd2fb6da70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f41574b57e704f944d925fd2fb6da70">&#9670;&#160;</a></span>StringMap() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ab37d4bea8d3ab483675b1026035ce3ae" name="ab37d4bea8d3ab483675b1026035ce3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37d4bea8d3ab483675b1026035ce3ae">&#9670;&#160;</a></span>StringMap() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b4053b534ba013066af6451c5881030" name="a8b4053b534ba013066af6451c5881030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4053b534ba013066af6451c5881030">&#9670;&#160;</a></span>StringMap() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="a8103d249b61e4a9a1f31a220ea18b9e3" name="a8103d249b61e4a9a1f31a220ea18b9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8103d249b61e4a9a1f31a220ea18b9e3">&#9670;&#160;</a></span>StringMap() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff22f9b763eb8e2e516d20e1f7f282a9" name="aff22f9b763eb8e2e516d20e1f7f282a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff22f9b763eb8e2e516d20e1f7f282a9">&#9670;&#160;</a></span>StringMap() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::StringMap </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a2297b050fce50cbd1dfec95c22e50c06">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Allocator()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer-list constructor. </p>
<p>Construct the container with the contents of the initializer list init. If multiple elements in the range have keys that compare equal, it is unspecified which element is inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">alloc</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a54e4c5eeb77c39b1b7e78fb66b391778" name="a54e4c5eeb77c39b1b7e78fb66b391778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e4c5eeb77c39b1b7e78fb66b391778">&#9670;&#160;</a></span>at() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the mapped value of the element with the specified key. </p>
<p>If no such element exists, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a01858aeb0ed53c9c3d2c69924ce81236" name="a01858aeb0ed53c9c3d2c69924ce81236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01858aeb0ed53c9c3d2c69924ce81236">&#9670;&#160;</a></span>at() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the mapped value of the element with the specified key. </p>
<p>If no such element exists, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a915a2e8d216b771929fe54e7eae8a68c" name="a915a2e8d216b771929fe54e7eae8a68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915a2e8d216b771929fe54e7eae8a68c">&#9670;&#160;</a></span>at() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the mapped value of the element with the specified key. </p>
<p>If no such element exists, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a7e66f7ea1bb8cf31d77d51a6302125d0" name="a7e66f7ea1bb8cf31d77d51a6302125d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e66f7ea1bb8cf31d77d51a6302125d0">&#9670;&#160;</a></span>at() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the mapped value of the element with the specified key. </p>
<p>If no such element exists, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a069733f0cf4b1b14a36a18d50e7f7328" name="a069733f0cf4b1b14a36a18d50e7f7328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069733f0cf4b1b14a36a18d50e7f7328">&#9670;&#160;</a></span>at() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the mapped value of the element with the specified key. </p>
<p>If no such element exists, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="afd232068fce36e1e608e92b38b36cde3" name="afd232068fce36e1e608e92b38b36cde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd232068fce36e1e608e92b38b36cde3">&#9670;&#160;</a></span>at() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the mapped value of the element with the specified key. </p>
<p>If no such element exists, an exception of type std::out_of_range is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the requested element. </dd></dl>

</div>
</div>
<a id="a6b47e972d36826e3b8c88cf031b6e002" name="a6b47e972d36826e3b8c88cf031b6e002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b47e972d36826e3b8c88cf031b6e002">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is an element with key equal to key in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is such an element, otherwise false </dd></dl>

</div>
</div>
<a id="a0b7a67758bffa7a31bda57186a3b17ee" name="a0b7a67758bffa7a31bda57186a3b17ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7a67758bffa7a31bda57186a3b17ee">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1153934dc8ee2991f3deace8b7cac8dc">size_type</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::count </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements with key that equals the specified argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the elements to count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with key that equals key (either 0 or 1). </dd></dl>

</div>
</div>
<a id="aed033547d911c826480115b302eff77f" name="aed033547d911c826480115b302eff77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed033547d911c826480115b302eff77f">&#9670;&#160;</a></span>emplace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container. </p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an interator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>

</div>
</div>
<a id="ae9a3b037272895b00ff6045e9e4025e5" name="ae9a3b037272895b00ff6045e9e4025e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3b037272895b00ff6045e9e4025e5">&#9670;&#160;</a></span>emplace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container. </p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an interator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>

</div>
</div>
<a id="a8802c911f7128c7362ab0f6f65208f70" name="a8802c911f7128c7362ab0f6f65208f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8802c911f7128c7362ab0f6f65208f70">&#9670;&#160;</a></span>emplace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element into the container constructed in-place with the given args, if there is no element with the key in the container. </p>
<p>No iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an interator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>

</div>
</div>
<a id="a6aea754578e5768be492b7e544c98175" name="a6aea754578e5768be492b7e544c98175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aea754578e5768be492b7e544c98175">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#af612eddd6b3f93b97557a7f56a3330f8" title="Returns an iterator pointing to the first element that is not less than (i.e.">lower_bound()</a>, and the second with <a class="el" href="#a204e9fcce572f186dd0458ea6164a3db" title="Returns an interator pointing to the first element that is greater than key.">upper_bound()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value to compare the elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of iterators defining the wanted range: the first pointing to the first element that is not less than key and the second pointing to the first element greater than key. If there are no elements not less than key, past-the-end (see end()) iterator is returned as the first element. Similarly if there are no elements greater than key, past-the-end iterator is returned as the second element. </dd></dl>

</div>
</div>
<a id="afca08ddceb4909310d47823843abfc1d" name="afca08ddceb4909310d47823843abfc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca08ddceb4909310d47823843abfc1d">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a>, <a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a range containing all elements with the given key in the container. </p>
<p>The range is defined by two iterators, one pointing to the first element that is not less than key and another pointing to the first element greater than key. Alternatively, the first iterator may be obtained with <a class="el" href="#af612eddd6b3f93b97557a7f56a3330f8" title="Returns an iterator pointing to the first element that is not less than (i.e.">lower_bound()</a>, and the second with <a class="el" href="#a204e9fcce572f186dd0458ea6164a3db" title="Returns an interator pointing to the first element that is greater than key.">upper_bound()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value to compare the elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair containing a pair of iterators defining the wanted range: the first pointing to the first element that is not less than key and the second pointing to the first element greater than key. If there are no elements not less than key, past-the-end (see end()) iterator is returned as the first element. Similarly if there are no elements greater than key, past-the-end iterator is returned as the second element. </dd></dl>

</div>
</div>
<a id="a6548500dcbb2050a7a7b174adfe32b18" name="a6548500dcbb2050a7a7b174adfe32b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6548500dcbb2050a7a7b174adfe32b18">&#9670;&#160;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last), which must be a valid range in this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start of the range of elements to remove </td></tr>
    <tr><td class="paramname">last</td><td>End of the range of elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="aafb95c23c213c73efe78d6e701348edf" name="aafb95c23c213c73efe78d6e701348edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb95c23c213c73efe78d6e701348edf">&#9670;&#160;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the removed element. </dd></dl>

</div>
</div>
<a id="ac2b2f1c9392cdb97cc7b581497e94c20" name="ac2b2f1c9392cdb97cc7b581497e94c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b2f1c9392cdb97cc7b581497e94c20">&#9670;&#160;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last), which must be a valid range in this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start of the range of elements to remove </td></tr>
    <tr><td class="paramname">last</td><td>End of the range of elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. </dd></dl>

</div>
</div>
<a id="acd79a05d779d7f6056502ff389f70f39" name="acd79a05d779d7f6056502ff389f70f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd79a05d779d7f6056502ff389f70f39">&#9670;&#160;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the removed element. </dd></dl>

</div>
</div>
<a id="aed59dee551b41503ce40ab38211fda10" name="aed59dee551b41503ce40ab38211fda10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed59dee551b41503ce40ab38211fda10">&#9670;&#160;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1153934dc8ee2991f3deace8b7cac8dc">size_type</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element (if one exists) with the key equal to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements removed (0 or 1). </dd></dl>

</div>
</div>
<a id="a275b9577f972e5299b7627acaa82ef3c" name="a275b9577f972e5299b7627acaa82ef3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275b9577f972e5299b7627acaa82ef3c">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab39e896c461bc832ee9665fa6df149e2">node_type</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlinks the node that contains the element pointed to by position and returns a node handle that owns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>a valid iterator into this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A node handle that owns the extracted element </dd></dl>

</div>
</div>
<a id="a0e0858e1a5869ac9de0482f53fb72146" name="a0e0858e1a5869ac9de0482f53fb72146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0858e1a5869ac9de0482f53fb72146">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab39e896c461bc832ee9665fa6df149e2">node_type</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the container has an element with key equal to key, unlinks the node that contains that element from the container and returns a node handle that owns it. </p>
<p>Otherwise, returns an empty node handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key to identify the node to be extracted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A node handle that owns the extracted element, or empty node handle in case the element is not found. </dd></dl>

</div>
</div>
<a id="af32b4dc3c432ee246667ea2f9eaf909f" name="af32b4dc3c432ee246667ea2f9eaf909f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32b4dc3c432ee246667ea2f9eaf909f">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equal to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see end()) iterator is returned. </dd></dl>

</div>
</div>
<a id="a8070535f81f1b69ef87d4523297ba647" name="a8070535f81f1b69ef87d4523297ba647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8070535f81f1b69ef87d4523297ba647">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element with key equal to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value of the element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the requested element. If no such element is found, past-the-end (see end()) iterator is returned. </dd></dl>

</div>
</div>
<a id="a299b66e17bfe13a5bfb713ff97bae65c" name="a299b66e17bfe13a5bfb713ff97bae65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299b66e17bfe13a5bfb713ff97bae65c">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key. </p>
<p>If the key does not exist, inserts the value as if by calling insert().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">obj</td><td>the value to insert or assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated. </dd></dl>

</div>
</div>
<a id="a01302fd57712a78773df96b05d0631de" name="a01302fd57712a78773df96b05d0631de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01302fd57712a78773df96b05d0631de">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key. </p>
<p>If the key does not exist, inserts the value as if by calling insert().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted </td></tr>
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">obj</td><td>the value to insert or assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing at the element that was inserted or updated. </dd></dl>

</div>
</div>
<a id="ab8c3a78f547f3e2508edad6a2b7eb912" name="ab8c3a78f547f3e2508edad6a2b7eb912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c3a78f547f3e2508edad6a2b7eb912">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key. </p>
<p>If the key does not exist, inserts the value as if by calling insert().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted </td></tr>
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">obj</td><td>the value to insert or assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing at the element that was inserted or updated. </dd></dl>

</div>
</div>
<a id="a5c31674898df47e49229700591e3b904" name="a5c31674898df47e49229700591e3b904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c31674898df47e49229700591e3b904">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key. </p>
<p>If the key does not exist, inserts the value as if by calling insert().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted </td></tr>
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">obj</td><td>the value to insert or assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing at the element that was inserted or updated. </dd></dl>

</div>
</div>
<a id="a990d6ef716e0c6f15b9387d2f0aee32f" name="a990d6ef716e0c6f15b9387d2f0aee32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990d6ef716e0c6f15b9387d2f0aee32f">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key. </p>
<p>If the key does not exist, inserts the value as if by calling insert().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">obj</td><td>the value to insert or assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated. </dd></dl>

</div>
</div>
<a id="a395ebba5835c6ca63f6b7bbc0efe3baf" name="a395ebba5835c6ca63f6b7bbc0efe3baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395ebba5835c6ca63f6b7bbc0efe3baf">&#9670;&#160;</a></span>insert_or_assign() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, assigns obj to the mapped type corresponding to that key. </p>
<p>If the key does not exist, inserts the value as if by calling insert().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">obj</td><td>the value to insert or assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated. </dd></dl>

</div>
</div>
<a id="af612eddd6b3f93b97557a7f56a3330f8" name="af612eddd6b3f93b97557a7f56a3330f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af612eddd6b3f93b97557a7f56a3330f8">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value to compare the elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator (see end()) is returned. </dd></dl>

</div>
</div>
<a id="a8b1542116fa94e27101c20c0487fea2f" name="a8b1542116fa94e27101c20c0487fea2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1542116fa94e27101c20c0487fea2f">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element that is not less than (i.e. </p>
<p>greater or equal to) key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value to compare the elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is not less than key. If no such element is found, a past-the-end iterator (see end()) is returned. </dd></dl>

</div>
</div>
<a id="a7bea7224513973f54413eb19fe3258b5" name="a7bea7224513973f54413eb19fe3258b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bea7224513973f54413eb19fe3258b5">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a2a808c6d70d723a7e09944ca290cfaee" name="a2a808c6d70d723a7e09944ca290cfaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a808c6d70d723a7e09944ca290cfaee">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="#a2297b050fce50cbd1dfec95c22e50c06">value_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ilist</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with those identified by initializer list ilist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>initializer list to use as data source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01dc3fda45dbdf614e047dc187b480b2" name="a01dc3fda45dbdf614e047dc187b480b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dc3fda45dbdf614e047dc187b480b2">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a> &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; T, Allocator &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a68d6353a713a25a5d347b805c1312c54" name="a68d6353a713a25a5d347b805c1312c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d6353a713a25a5d347b805c1312c54">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the new element if no element with key key existed. Otherwise, a reference to the mapped value of the existing element whose key is equal to key. </dd></dl>

</div>
</div>
<a id="a08660fd40faa7026744fb4ca23dfe4c7" name="a08660fd40faa7026744fb4ca23dfe4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08660fd40faa7026744fb4ca23dfe4c7">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the new element if no element with key key existed. Otherwise, a reference to the mapped value of the existing element whose key is equal to key. </dd></dl>

</div>
</div>
<a id="aaa8355450eef9ca122b30b1c29f527da" name="aaa8355450eef9ca122b30b1c29f527da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8355450eef9ca122b30b1c29f527da">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the new element if no element with key key existed. Otherwise, a reference to the mapped value of the existing element whose key is equal to key. </dd></dl>

</div>
</div>
<a id="ac29c70d30572d10219368c20b87a1c51" name="ac29c70d30572d10219368c20b87a1c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29c70d30572d10219368c20b87a1c51">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the value that is mapped to a key, performing an insertion if such a key does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the element to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value of the new element if no element with key key existed. Otherwise, a reference to the mapped value of the existing element whose key is equal to key. </dd></dl>

</div>
</div>
<a id="aefdd9ebe17f1ee0ae836a83018c72b96" name="aefdd9ebe17f1ee0ae836a83018c72b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdd9ebe17f1ee0ae836a83018c72b96">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a>&lt; T, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of other. </p>
<p>Does not invoke any move, copy, or swap operations on individual elements.</p>
<p>All iterators and references remain valid. The end() iterator is invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a9de194dd108bb65a0a4c2a678c387a" name="a6a9de194dd108bb65a0a4c2a678c387a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9de194dd108bb65a0a4c2a678c387a">&#9670;&#160;</a></span>try_emplace() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, does nothing. </p>
<p>Otherwise, inserts a new element into the container with key key and value constructed with args.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an interator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>

</div>
</div>
<a id="ad15703bd0a9459b3e284617112eac91b" name="ad15703bd0a9459b3e284617112eac91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15703bd0a9459b3e284617112eac91b">&#9670;&#160;</a></span>try_emplace() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, does nothing. </p>
<p>Otherwise, inserts a new element into the container with key key and value constructed with args.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted </td></tr>
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An interator to the inserted element, or to the element that prevented the insertion. </dd></dl>

</div>
</div>
<a id="ab46e95985135713b786095102c6b91e7" name="ab46e95985135713b786095102c6b91e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46e95985135713b786095102c6b91e7">&#9670;&#160;</a></span>try_emplace() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, does nothing. </p>
<p>Otherwise, inserts a new element into the container with key key and value constructed with args.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted </td></tr>
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An interator to the inserted element, or to the element that prevented the insertion. </dd></dl>

</div>
</div>
<a id="a25da22cdf2b8f4a2aee32e734d909472" name="a25da22cdf2b8f4a2aee32e734d909472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25da22cdf2b8f4a2aee32e734d909472">&#9670;&#160;</a></span>try_emplace() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, does nothing. </p>
<p>Otherwise, inserts a new element into the container with key key and value constructed with args.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hint</td><td>iterator to the position before which the new element will be inserted </td></tr>
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An interator to the inserted element, or to the element that prevented the insertion. </dd></dl>

</div>
</div>
<a id="acfc35740db20d45109f32670992f5341" name="acfc35740db20d45109f32670992f5341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc35740db20d45109f32670992f5341">&#9670;&#160;</a></span>try_emplace() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, does nothing. </p>
<p>Otherwise, inserts a new element into the container with key key and value constructed with args.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an interator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>

</div>
</div>
<a id="a42c088e214e41b991b6b4a440634bd54" name="a42c088e214e41b991b6b4a440634bd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c088e214e41b991b6b4a440634bd54">&#9670;&#160;</a></span>try_emplace() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a>, bool &gt; <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::try_emplace </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a key equal to key already exists in the container, does nothing. </p>
<p>Otherwise, inserts a new element into the container with key key and value constructed with args.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key used both to look up and to insert if not found </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of an interator to the inserted element (or to the element that prevented the insertion) and a bool value set to true if and only if the insertion took place. </dd></dl>

</div>
</div>
<a id="a204e9fcce572f186dd0458ea6164a3db" name="a204e9fcce572f186dd0458ea6164a3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204e9fcce572f186dd0458ea6164a3db">&#9670;&#160;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af25fd3a556c507e72a1795b8e3fd4cf0">iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an interator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value to compare the elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, past-the-end (see end()) iterator is returned. </dd></dl>

</div>
</div>
<a id="a38071add9a6f14827f567b19b527e968" name="a38071add9a6f14827f567b19b527e968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38071add9a6f14827f567b19b527e968">&#9670;&#160;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;std::pair&lt;const std::string, T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac373b8ae667f88ea953176906cf2ec06">const_iterator</a> <a class="el" href="classwpi_1_1_string_map.html">wpi::StringMap</a>&lt; T, Allocator &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an interator pointing to the first element that is greater than key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key value to compare the elements to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the first element that is greater than key. If no such element is found, past-the-end (see end()) iterator is returned. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>wpi/<a class="el" href="_string_map_8h_source.html">StringMap.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewpi.html">wpi</a></li><li class="navelem"><a class="el" href="classwpi_1_1_string_map.html">StringMap</a></li>
    <li class="footer">Generated on Sat May 31 2025 13:41:26 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
