<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WPILibC++: slp::Problem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="wpilib-128.png"/></td>
  <td id="projectalign">
   <div id="projectname">WPILibC++<span id="projectnumber">&#160;2025.3.2-54-g7a3df61</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classslp_1_1_problem.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classslp_1_1_problem-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">slp::Problem Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class allows the user to pose a constrained nonlinear optimization problem in natural mathematical notation and solve it.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="problem_8hpp_source.html">/home/runner/work/allwpilib/allwpilib/wpimath/src/main/native/thirdparty/sleipnir/include/sleipnir/optimization/problem.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for slp::Problem:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classslp_1_1_problem.png" usemap="#slp::Problem_map" alt=""/>
  <map id="slp::Problem_map" name="slp::Problem_map">
<area href="classslp_1_1_o_c_p.html" title="This class allows the user to pose and solve a constrained optimal control problem (OCP) in a variety..." alt="slp::OCP" shape="rect" coords="0,56,80,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2447471010c76066ea11e398314fb155" id="r_a2447471010c76066ea11e398314fb155"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2447471010c76066ea11e398314fb155">Problem</a> () noexcept=default</td></tr>
<tr class="memdesc:a2447471010c76066ea11e398314fb155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the optimization problem.  <br /></td></tr>
<tr class="separator:a2447471010c76066ea11e398314fb155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4001fb937a3ca028186201825d1818" id="r_a0c4001fb937a3ca028186201825d1818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslp_1_1_variable.html">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c4001fb937a3ca028186201825d1818">decision_variable</a> ()</td></tr>
<tr class="memdesc:a0c4001fb937a3ca028186201825d1818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a decision variable in the optimization problem.  <br /></td></tr>
<tr class="separator:a0c4001fb937a3ca028186201825d1818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12424d1c22dba4620c40325715925b3f" id="r_a12424d1c22dba4620c40325715925b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12424d1c22dba4620c40325715925b3f">decision_variable</a> (int rows, int cols=1)</td></tr>
<tr class="memdesc:a12424d1c22dba4620c40325715925b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix of decision variables in the optimization problem.  <br /></td></tr>
<tr class="separator:a12424d1c22dba4620c40325715925b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981b9f578a3208f7654341e3b2adc944" id="r_a981b9f578a3208f7654341e3b2adc944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981b9f578a3208f7654341e3b2adc944">symmetric_decision_variable</a> (int rows)</td></tr>
<tr class="memdesc:a981b9f578a3208f7654341e3b2adc944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symmetric matrix of decision variables in the optimization problem.  <br /></td></tr>
<tr class="separator:a981b9f578a3208f7654341e3b2adc944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb4722e6973f059ff71fd2c52b2ff6a" id="r_a7fb4722e6973f059ff71fd2c52b2ff6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fb4722e6973f059ff71fd2c52b2ff6a">minimize</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;cost)</td></tr>
<tr class="memdesc:a7fb4722e6973f059ff71fd2c52b2ff6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to minimize the output of the given cost function.  <br /></td></tr>
<tr class="separator:a7fb4722e6973f059ff71fd2c52b2ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ec587143dfc05c1a2f1fba03b413bd" id="r_ae0ec587143dfc05c1a2f1fba03b413bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0ec587143dfc05c1a2f1fba03b413bd">minimize</a> (<a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;&amp;cost)</td></tr>
<tr class="memdesc:ae0ec587143dfc05c1a2f1fba03b413bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to minimize the output of the given cost function.  <br /></td></tr>
<tr class="separator:ae0ec587143dfc05c1a2f1fba03b413bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e3c14775ac5deed29026b73ba29a05" id="r_ab4e3c14775ac5deed29026b73ba29a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4e3c14775ac5deed29026b73ba29a05">maximize</a> (const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;objective)</td></tr>
<tr class="memdesc:ab4e3c14775ac5deed29026b73ba29a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to maximize the output of the given objective function.  <br /></td></tr>
<tr class="separator:ab4e3c14775ac5deed29026b73ba29a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350926b74876f3de7b0b066832cf4b1b" id="r_a350926b74876f3de7b0b066832cf4b1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a350926b74876f3de7b0b066832cf4b1b">maximize</a> (<a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;&amp;objective)</td></tr>
<tr class="memdesc:a350926b74876f3de7b0b066832cf4b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to maximize the output of the given objective function.  <br /></td></tr>
<tr class="separator:a350926b74876f3de7b0b066832cf4b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e10011f6b3a67f97a430986f649647" id="r_a08e10011f6b3a67f97a430986f649647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e10011f6b3a67f97a430986f649647">subject_to</a> (const <a class="el" href="structslp_1_1_equality_constraints.html">EqualityConstraints</a> &amp;constraint)</td></tr>
<tr class="memdesc:a08e10011f6b3a67f97a430986f649647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given equality constraint.  <br /></td></tr>
<tr class="separator:a08e10011f6b3a67f97a430986f649647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c357b9ca5f1a2ed03d4de825252c1cf" id="r_a9c357b9ca5f1a2ed03d4de825252c1cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c357b9ca5f1a2ed03d4de825252c1cf">subject_to</a> (<a class="el" href="structslp_1_1_equality_constraints.html">EqualityConstraints</a> &amp;&amp;constraint)</td></tr>
<tr class="memdesc:a9c357b9ca5f1a2ed03d4de825252c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given equality constraint.  <br /></td></tr>
<tr class="separator:a9c357b9ca5f1a2ed03d4de825252c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ca5bdef705b009040935575ebff3e7" id="r_ae8ca5bdef705b009040935575ebff3e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8ca5bdef705b009040935575ebff3e7">subject_to</a> (const <a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> &amp;constraint)</td></tr>
<tr class="memdesc:ae8ca5bdef705b009040935575ebff3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given inequality constraint.  <br /></td></tr>
<tr class="separator:ae8ca5bdef705b009040935575ebff3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d487bfa6c10d893c4ca5d215160221" id="r_a67d487bfa6c10d893c4ca5d215160221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67d487bfa6c10d893c4ca5d215160221">subject_to</a> (<a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> &amp;&amp;constraint)</td></tr>
<tr class="memdesc:a67d487bfa6c10d893c4ca5d215160221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the solver to solve the problem while satisfying the given inequality constraint.  <br /></td></tr>
<tr class="separator:a67d487bfa6c10d893c4ca5d215160221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b168233aef21244ad0cedcf7fcc23" id="r_acb6b168233aef21244ad0cedcf7fcc23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceslp.html#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb6b168233aef21244ad0cedcf7fcc23">cost_function_type</a> () const</td></tr>
<tr class="memdesc:acb6b168233aef21244ad0cedcf7fcc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cost function's type.  <br /></td></tr>
<tr class="separator:acb6b168233aef21244ad0cedcf7fcc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9b321c9b8363f3d4df3aae9d0b5f91" id="r_a4f9b321c9b8363f3d4df3aae9d0b5f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceslp.html#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f9b321c9b8363f3d4df3aae9d0b5f91">equality_constraint_type</a> () const</td></tr>
<tr class="memdesc:a4f9b321c9b8363f3d4df3aae9d0b5f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the highest order equality constraint.  <br /></td></tr>
<tr class="separator:a4f9b321c9b8363f3d4df3aae9d0b5f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af748b062c91ef8b1af7af0509501d923" id="r_af748b062c91ef8b1af7af0509501d923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceslp.html#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af748b062c91ef8b1af7af0509501d923">inequality_constraint_type</a> () const</td></tr>
<tr class="memdesc:af748b062c91ef8b1af7af0509501d923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the highest order inequality constraint.  <br /></td></tr>
<tr class="separator:af748b062c91ef8b1af7af0509501d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bced471358bf7c01c08a5bda4e73b7" id="r_a45bced471358bf7c01c08a5bda4e73b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceslp.html#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45bced471358bf7c01c08a5bda4e73b7">solve</a> (const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;options=<a class="el" href="structslp_1_1_options.html">Options</a>{}, bool spy=false)</td></tr>
<tr class="memdesc:a45bced471358bf7c01c08a5bda4e73b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the optimization problem.  <br /></td></tr>
<tr class="separator:a45bced471358bf7c01c08a5bda4e73b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b2eccf947e40aea16cfb620c8bedb7" id="r_ac4b2eccf947e40aea16cfb620c8bedb7"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; <br />
requires requires(F callback, const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a>&amp; info) { { callback(info) } -&gt; std::same_as&lt;void&gt;; }</td></tr>
<tr class="memitem:ac4b2eccf947e40aea16cfb620c8bedb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4b2eccf947e40aea16cfb620c8bedb7">add_callback</a> (F &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac4b2eccf947e40aea16cfb620c8bedb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to be called at the beginning of each solver iteration.  <br /></td></tr>
<tr class="separator:ac4b2eccf947e40aea16cfb620c8bedb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a3c84ec2ab0cfdb8cb23dd09dfa376" id="r_ad3a3c84ec2ab0cfdb8cb23dd09dfa376"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; <br />
requires requires(F callback, const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a>&amp; info) { { callback(info) } -&gt; std::same_as&lt;bool&gt;; }</td></tr>
<tr class="memitem:ad3a3c84ec2ab0cfdb8cb23dd09dfa376"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3a3c84ec2ab0cfdb8cb23dd09dfa376">add_callback</a> (F &amp;&amp;callback)</td></tr>
<tr class="memdesc:ad3a3c84ec2ab0cfdb8cb23dd09dfa376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to be called at the beginning of each solver iteration.  <br /></td></tr>
<tr class="separator:ad3a3c84ec2ab0cfdb8cb23dd09dfa376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a11fc945096cdb2ea162691b3d1b2c" id="r_a02a11fc945096cdb2ea162691b3d1b2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a11fc945096cdb2ea162691b3d1b2c">clear_callbacks</a> ()</td></tr>
<tr class="memdesc:a02a11fc945096cdb2ea162691b3d1b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the registered callbacks.  <br /></td></tr>
<tr class="separator:a02a11fc945096cdb2ea162691b3d1b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class allows the user to pose a constrained nonlinear optimization problem in natural mathematical notation and solve it. </p>
<p>This class supports problems of the form: </p><pre class="fragment">      minₓ f(x)
subject to cₑ(x) = 0
           cᵢ(x) ≥ 0
</pre><p>where f(x) is the scalar cost function, x is the vector of decision variables (variables the solver can tweak to minimize the cost function), cᵢ(x) are the inequality constraints, and cₑ(x) are the equality constraints. Constraints are equations or inequalities of the decision variables that constrain what values the solver is allowed to use when searching for an optimal solution.</p>
<p>The nice thing about this class is users don't have to put their system in the form shown above manually; they can write it in natural mathematical form and it'll be converted for them. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2447471010c76066ea11e398314fb155" name="a2447471010c76066ea11e398314fb155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2447471010c76066ea11e398314fb155">&#9670;&#160;</a></span>Problem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">slp::Problem::Problem </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the optimization problem. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4b2eccf947e40aea16cfb620c8bedb7" name="ac4b2eccf947e40aea16cfb620c8bedb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b2eccf947e40aea16cfb620c8bedb7">&#9670;&#160;</a></span>add_callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; <br />
requires requires(F callback, const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a>&amp; info) { { callback(info) } -&gt; std::same_as&lt;void&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::add_callback </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback to be called at the beginning of each solver iteration. </p>
<p>The callback for this overload should return void.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a3c84ec2ab0cfdb8cb23dd09dfa376" name="ad3a3c84ec2ab0cfdb8cb23dd09dfa376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a3c84ec2ab0cfdb8cb23dd09dfa376">&#9670;&#160;</a></span>add_callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; <br />
requires requires(F callback, const <a class="el" href="structslp_1_1_iteration_info.html">IterationInfo</a>&amp; info) { { callback(info) } -&gt; std::same_as&lt;bool&gt;; }</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::add_callback </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback to be called at the beginning of each solver iteration. </p>
<p>The callback for this overload should return bool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback. Returning true from the callback causes the solver to exit early with the solution it has so far. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02a11fc945096cdb2ea162691b3d1b2c" name="a02a11fc945096cdb2ea162691b3d1b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a11fc945096cdb2ea162691b3d1b2c">&#9670;&#160;</a></span>clear_callbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::clear_callbacks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the registered callbacks. </p>

</div>
</div>
<a id="acb6b168233aef21244ad0cedcf7fcc23" name="acb6b168233aef21244ad0cedcf7fcc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6b168233aef21244ad0cedcf7fcc23">&#9670;&#160;</a></span>cost_function_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceslp.html#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a> slp::Problem::cost_function_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cost function's type. </p>
<dl class="section return"><dt>Returns</dt><dd>The cost function's type. </dd></dl>

</div>
</div>
<a id="a0c4001fb937a3ca028186201825d1818" name="a0c4001fb937a3ca028186201825d1818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4001fb937a3ca028186201825d1818">&#9670;&#160;</a></span>decision_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslp_1_1_variable.html">Variable</a> slp::Problem::decision_variable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a decision variable in the optimization problem. </p>
<dl class="section return"><dt>Returns</dt><dd>A decision variable in the optimization problem. </dd></dl>

</div>
</div>
<a id="a12424d1c22dba4620c40325715925b3f" name="a12424d1c22dba4620c40325715925b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12424d1c22dba4620c40325715925b3f">&#9670;&#160;</a></span>decision_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> slp::Problem::decision_variable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matrix of decision variables in the optimization problem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of matrix rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of matrix columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix of decision variables in the optimization problem. </dd></dl>

</div>
</div>
<a id="a4f9b321c9b8363f3d4df3aae9d0b5f91" name="a4f9b321c9b8363f3d4df3aae9d0b5f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9b321c9b8363f3d4df3aae9d0b5f91">&#9670;&#160;</a></span>equality_constraint_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceslp.html#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a> slp::Problem::equality_constraint_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the highest order equality constraint. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the highest order equality constraint. </dd></dl>

</div>
</div>
<a id="af748b062c91ef8b1af7af0509501d923" name="af748b062c91ef8b1af7af0509501d923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af748b062c91ef8b1af7af0509501d923">&#9670;&#160;</a></span>inequality_constraint_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceslp.html#a46f7c3be6708b8f35512e31531b025e5">ExpressionType</a> slp::Problem::inequality_constraint_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the highest order inequality constraint. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the highest order inequality constraint. </dd></dl>

</div>
</div>
<a id="ab4e3c14775ac5deed29026b73ba29a05" name="ab4e3c14775ac5deed29026b73ba29a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e3c14775ac5deed29026b73ba29a05">&#9670;&#160;</a></span>maximize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::maximize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>objective</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to maximize the output of the given objective function. </p>
<p>Note that this is optional. If only constraints are specified, the solver will find the closest solution to the initial conditions that's in the feasible set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objective</td><td>The objective function to maximize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a350926b74876f3de7b0b066832cf4b1b" name="a350926b74876f3de7b0b066832cf4b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350926b74876f3de7b0b066832cf4b1b">&#9670;&#160;</a></span>maximize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::maximize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>objective</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to maximize the output of the given objective function. </p>
<p>Note that this is optional. If only constraints are specified, the solver will find the closest solution to the initial conditions that's in the feasible set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objective</td><td>The objective function to maximize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fb4722e6973f059ff71fd2c52b2ff6a" name="a7fb4722e6973f059ff71fd2c52b2ff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb4722e6973f059ff71fd2c52b2ff6a">&#9670;&#160;</a></span>minimize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::minimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cost</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to minimize the output of the given cost function. </p>
<p>Note that this is optional. If only constraints are specified, the solver will find the closest solution to the initial conditions that's in the feasible set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost</td><td>The cost function to minimize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0ec587143dfc05c1a2f1fba03b413bd" name="ae0ec587143dfc05c1a2f1fba03b413bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ec587143dfc05c1a2f1fba03b413bd">&#9670;&#160;</a></span>minimize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::minimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classslp_1_1_variable.html">Variable</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cost</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to minimize the output of the given cost function. </p>
<p>Note that this is optional. If only constraints are specified, the solver will find the closest solution to the initial conditions that's in the feasible set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost</td><td>The cost function to minimize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45bced471358bf7c01c08a5bda4e73b7" name="a45bced471358bf7c01c08a5bda4e73b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bced471358bf7c01c08a5bda4e73b7">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceslp.html#a64d9dd92f6b87c30cd61389af1adb8cd">ExitStatus</a> slp::Problem::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structslp_1_1_options.html">Options</a>{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>spy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the optimization problem. </p>
<p>The solution will be stored in the original variables used to construct the problem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Solver options. </td></tr>
    <tr><td class="paramname">spy</td><td>Enables writing sparsity patterns of H, Aₑ, and Aᵢ to files named H.spy, A_e.spy, and A_i.spy respectively during solve. Use tools/spy.py to plot them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The solver status. </dd></dl>

</div>
</div>
<a id="a08e10011f6b3a67f97a430986f649647" name="a08e10011f6b3a67f97a430986f649647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e10011f6b3a67f97a430986f649647">&#9670;&#160;</a></span>subject_to() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::subject_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_equality_constraints.html">EqualityConstraints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to solve the problem while satisfying the given equality constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>The constraint to satisfy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8ca5bdef705b009040935575ebff3e7" name="ae8ca5bdef705b009040935575ebff3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ca5bdef705b009040935575ebff3e7">&#9670;&#160;</a></span>subject_to() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::subject_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to solve the problem while satisfying the given inequality constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>The constraint to satisfy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c357b9ca5f1a2ed03d4de825252c1cf" name="a9c357b9ca5f1a2ed03d4de825252c1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c357b9ca5f1a2ed03d4de825252c1cf">&#9670;&#160;</a></span>subject_to() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::subject_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structslp_1_1_equality_constraints.html">EqualityConstraints</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to solve the problem while satisfying the given equality constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>The constraint to satisfy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67d487bfa6c10d893c4ca5d215160221" name="a67d487bfa6c10d893c4ca5d215160221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d487bfa6c10d893c4ca5d215160221">&#9670;&#160;</a></span>subject_to() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void slp::Problem::subject_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structslp_1_1_inequality_constraints.html">InequalityConstraints</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the solver to solve the problem while satisfying the given inequality constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>The constraint to satisfy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a981b9f578a3208f7654341e3b2adc944" name="a981b9f578a3208f7654341e3b2adc944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981b9f578a3208f7654341e3b2adc944">&#9670;&#160;</a></span>symmetric_decision_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classslp_1_1_variable_matrix.html">VariableMatrix</a> slp::Problem::symmetric_decision_variable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symmetric matrix of decision variables in the optimization problem. </p>
<p><a class="el" href="classslp_1_1_variable.html" title="An autodiff variable pointing to an expression node.">Variable</a> instances are reused across the diagonal, which helps reduce problem dimensionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of matrix rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A symmetric matrix of decision varaibles in the optimization problem. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/allwpilib/allwpilib/wpimath/src/main/native/thirdparty/sleipnir/include/sleipnir/optimization/<a class="el" href="problem_8hpp_source.html">problem.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceslp.html">slp</a></li><li class="navelem"><a class="el" href="classslp_1_1_problem.html">Problem</a></li>
    <li class="footer">Generated on Sat May 31 2025 13:41:24 for WPILibC++ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
